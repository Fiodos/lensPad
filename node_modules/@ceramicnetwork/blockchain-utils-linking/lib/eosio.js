"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toSignedPayload = exports.toPayload = exports.EosioAuthProvider = void 0;
const caip_1 = require("caip");
const util_1 = require("./util");
const ethereum_1 = require("./ethereum");
const sha256Stable = __importStar(require("@stablelib/sha256"));
const uint8arrays = __importStar(require("uint8arrays"));
const maxWordLength = 12;
class EosioAuthProvider {
    constructor(provider, address) {
        this.provider = provider;
        this.address = address;
        this.isAuthProvider = true;
    }
    async accountId() {
        const chainId = toCAIPChainId(await this.provider.getChainId());
        return new caip_1.AccountID({
            address: this.address,
            chainId: `eosio:${chainId}`,
        });
    }
    async authenticate(message) {
        const accountID = await this.accountId();
        const signedPayload = await toSignedPayload(message, accountID, this.provider);
        const signatureBytes = uint8arrays.fromString(signedPayload);
        const digest = sha256Stable.hash(signatureBytes);
        return `0x${uint8arrays.toString(digest, 'base16')}`;
    }
    async createLink(did) {
        const consentMessage = util_1.getConsentMessage(did);
        const accountID = await this.accountId();
        const signedPayload = await toSignedPayload(consentMessage.message, accountID, this.provider);
        return {
            version: 2,
            type: 'eosio',
            message: consentMessage.message,
            signature: signedPayload,
            account: accountID.toString(),
            timestamp: consentMessage.timestamp,
        };
    }
    withAddress(address) {
        return new EosioAuthProvider(this.provider, address);
    }
}
exports.EosioAuthProvider = EosioAuthProvider;
function toCAIPChainId(chainId) {
    return chainId.substr(0, 32);
}
function sanitize(str, size) {
    return str.replace(/\s/g, ' ').replace(new RegExp(`(\\S{${size}})`, 'g'), '$1 ');
}
function toPayload(message, accountID) {
    const { address, chainId } = accountID;
    const payload = `${message} [For: ${address} on chain: ${chainId}]`;
    return sanitize(payload, maxWordLength);
}
exports.toPayload = toPayload;
async function toSignedPayload(message, accountID, provider) {
    accountID = ethereum_1.normalizeAccountId(accountID);
    const { chainId: { reference: requestedChainId }, address, } = accountID;
    const accountName = await provider.getAccountName();
    const chainId = toCAIPChainId(await provider.getChainId());
    if (chainId !== requestedChainId) {
        throw new Error(`Provider returned a different chainId than requested [returned: ${chainId}, requested: ${requestedChainId}]`);
    }
    if (accountName !== address) {
        throw new Error(`Provider returned a different account than requested [returned: ${accountName}, requested: ${address}]`);
    }
    const payload = toPayload(message, accountID);
    const [key] = await provider.getKeys();
    return provider.signArbitrary(key, payload);
}
exports.toSignedPayload = toSignedPayload;
//# sourceMappingURL=eosio.js.map