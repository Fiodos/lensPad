"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authenticate = exports.createLink = exports.normalizeAccountId = exports.isERC1271 = exports.isEthAddress = exports.EthereumAuthProvider = void 0;
const caip_1 = require("caip");
const util_1 = require("./util");
const uint8arrays = __importStar(require("uint8arrays"));
const sha256 = __importStar(require("@stablelib/sha256"));
const ocap_util_1 = require("./ocap-util");
const ADDRESS_TYPES = {
    ethereumEOA: 'ethereum-eoa',
    erc1271: 'erc1271',
};
const CHAIN_NAMESPACE = 'eip155';
class EthereumAuthProvider {
    constructor(provider, address, opts = {}) {
        this.provider = provider;
        this.address = address;
        this.opts = opts;
        this.isAuthProvider = true;
    }
    async accountId() {
        const chainIdHex = await safeSend(this.provider, 'eth_chainId', []);
        const chainId = parseInt(chainIdHex, 16);
        return new caip_1.AccountID({
            address: this.address,
            chainId: `${CHAIN_NAMESPACE}:${chainId}`,
        });
    }
    async authenticate(message) {
        const accountId = await this.accountId();
        return authenticate(message, accountId, this.provider);
    }
    async createLink(did) {
        const accountId = await this.accountId();
        return createLink(did, accountId, this.provider, this.opts);
    }
    async requestCapability(params) {
        console.warn('WARN: requestCapability os an experimental API, that is subject to change any time.');
        const account = await this.accountId();
        const requestMessage = ocap_util_1.buildOcapRequestMessage({
            ...params,
            address: this.address,
            chainId: account.chainId.toString(),
            type: ocap_util_1.OcapTypes.EIP4361,
        });
        const signature = await safeSend(this.provider, 'personal_sign', [
            requestMessage,
            account.address,
        ]);
        return {
            message: requestMessage,
            signature: signature,
        };
    }
    withAddress(address) {
        return new EthereumAuthProvider(this.provider, address);
    }
}
exports.EthereumAuthProvider = EthereumAuthProvider;
function isEthAddress(address) {
    return /^0x[a-fA-F0-9]{40}$/.test(address);
}
exports.isEthAddress = isEthAddress;
async function getCode(address, provider) {
    return safeSend(provider, 'eth_getCode', [address, 'latest']);
}
function safeSend(provider, method, params) {
    if (params == null) {
        params = [];
    }
    if (provider.request) {
        return provider.request({ method, params }).then((response) => response, (error) => {
            throw error;
        });
    }
    else if (provider.sendAsync || provider.send) {
        const sendFunc = (provider.sendAsync ? provider.sendAsync : provider.send).bind(provider);
        const request = util_1.encodeRpcMessage(method, params);
        return new Promise((resolve, reject) => {
            sendFunc(request, (error, response) => {
                if (error)
                    reject(error);
                if (response.error) {
                    const error = new Error(response.error.message);
                    error.code = response.error.code;
                    error.data = response.error.data;
                    reject(error);
                }
                resolve(response.result);
            });
        });
    }
    else {
        throw new Error(`Unsupported provider; provider must implement one of the following methods: send, sendAsync, request`);
    }
}
async function isERC1271(account, provider) {
    const bytecode = await getCode(account.address, provider).catch(() => null);
    return Boolean(bytecode && bytecode !== '0x' && bytecode !== '0x0' && bytecode !== '0x00');
}
exports.isERC1271 = isERC1271;
function normalizeAccountId(account) {
    account.address = account.address.toLowerCase();
    return account;
}
exports.normalizeAccountId = normalizeAccountId;
function utf8toHex(message) {
    const bytes = uint8arrays.fromString(message);
    const hex = uint8arrays.toString(bytes, 'base16');
    return '0x' + hex;
}
async function createEthLink(did, account, provider, opts = {}) {
    const { message, timestamp } = util_1.getConsentMessage(did, !opts.skipTimestamp);
    const hexMessage = utf8toHex(message);
    const signature = await safeSend(provider, 'personal_sign', [hexMessage, account.address]);
    const proof = {
        version: 2,
        type: ADDRESS_TYPES.ethereumEOA,
        message,
        signature,
        account: account.toString(),
    };
    if (!opts.skipTimestamp)
        proof.timestamp = timestamp;
    return proof;
}
async function validateChainId(account, provider) {
    const chainIdHex = await safeSend(provider, 'eth_chainId', []);
    const chainId = parseInt(chainIdHex, 16);
    if (chainId !== parseInt(account.chainId.reference)) {
        throw new Error(`ChainId in provider (${chainId}) is different from AccountID (${account.chainId.reference})`);
    }
}
async function createErc1271Link(did, account, provider, opts) {
    const ethLinkAccount = (opts === null || opts === void 0 ? void 0 : opts.eoaSignAccount) || account;
    const res = await createEthLink(did, ethLinkAccount, provider, opts);
    await validateChainId(account, provider);
    return Object.assign(res, {
        type: ADDRESS_TYPES.erc1271,
        account: account.toString(),
    });
}
async function createLink(did, account, provider, opts) {
    account = normalizeAccountId(account);
    if (await isERC1271(account, provider)) {
        return createErc1271Link(did, account, provider, opts);
    }
    else {
        return createEthLink(did, account, provider, opts);
    }
}
exports.createLink = createLink;
async function authenticate(message, account, provider) {
    if (account)
        account = normalizeAccountId(account);
    if (provider.isAuthereum)
        return provider.signMessageWithSigningKey(message);
    const hexMessage = utf8toHex(message);
    const signature = await safeSend(provider, 'personal_sign', [hexMessage, account.address]);
    const signatureBytes = uint8arrays.fromString(signature.slice(2));
    const digest = sha256.hash(signatureBytes);
    return `0x${uint8arrays.toString(digest, 'base16')}`;
}
exports.authenticate = authenticate;
//# sourceMappingURL=ethereum.js.map