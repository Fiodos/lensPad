'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var transportSubject = require('@ceramicnetwork/transport-subject');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');

function createOriginFilter(allowedOrigin) {
  if (!Array.isArray(allowedOrigin)) {
    allowedOrigin = [allowedOrigin];
  }

  return function (event) {
    return allowedOrigin.includes(event.origin);
  };
}
function createMessageObservable(target, originOrFilter) {
  var source = rxjs.fromEvent(target, 'message');

  if (originOrFilter == null) {
    return source;
  }

  var messageFilter = typeof originOrFilter === 'function' ? originOrFilter : createOriginFilter(originOrFilter);
  return source.pipe(operators.filter(messageFilter));
}
function createPostMessageObserver(target) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return rxjs.Subscriber.create(function (message) {
    if (message != null) {
      target.postMessage.apply(target, [message].concat(args));
    }
  });
}
function createPostMessageTransport(from, to, _temp) {
  if (to === void 0) {
    to = from;
  }

  var _ref = _temp === void 0 ? {} : _temp,
      filter = _ref.filter,
      _ref$postMessageArgum = _ref.postMessageArguments,
      postMessageArguments = _ref$postMessageArgum === void 0 ? [] : _ref$postMessageArgum;

  var source = createMessageObservable(from, filter);
  var sink = createPostMessageObserver.apply(void 0, [to].concat(postMessageArguments));
  return new transportSubject.TransportSubject(source, sink);
}

exports.createMessageObservable = createMessageObservable;
exports.createOriginFilter = createOriginFilter;
exports.createPostMessageObserver = createPostMessageObserver;
exports.createPostMessageTransport = createPostMessageTransport;
//# sourceMappingURL=transport-postmessage.cjs.development.js.map
