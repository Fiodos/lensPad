import { TransportSubject } from '@ceramicnetwork/transport-subject';
import { fromEvent, Subscriber } from 'rxjs';
import { filter } from 'rxjs/operators';

function createOriginFilter(allowedOrigin) {
  if (!Array.isArray(allowedOrigin)) {
    allowedOrigin = [allowedOrigin];
  }

  return function (event) {
    return allowedOrigin.includes(event.origin);
  };
}
function createMessageObservable(target, originOrFilter) {
  var source = fromEvent(target, 'message');

  if (originOrFilter == null) {
    return source;
  }

  var messageFilter = typeof originOrFilter === 'function' ? originOrFilter : createOriginFilter(originOrFilter);
  return source.pipe(filter(messageFilter));
}
function createPostMessageObserver(target) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return Subscriber.create(function (message) {
    if (message != null) {
      target.postMessage.apply(target, [message].concat(args));
    }
  });
}
function createPostMessageTransport(from, to, _temp) {
  if (to === void 0) {
    to = from;
  }

  var _ref = _temp === void 0 ? {} : _temp,
      filter = _ref.filter,
      _ref$postMessageArgum = _ref.postMessageArguments,
      postMessageArguments = _ref$postMessageArgum === void 0 ? [] : _ref$postMessageArgum;

  var source = createMessageObservable(from, filter);
  var sink = createPostMessageObserver.apply(void 0, [to].concat(postMessageArguments));
  return new TransportSubject(source, sink);
}

export { createMessageObservable, createOriginFilter, createPostMessageObserver, createPostMessageTransport };
//# sourceMappingURL=transport-postmessage.esm.js.map
