import type { CeramicApi, StreamMetadata } from '@ceramicnetwork/common';
import type { StreamRef } from '@ceramicnetwork/streamid';
import type { TileDocument } from '@ceramicnetwork/stream-tile';
import type { DagJWSResult } from 'dids';
import type { Definition, EncodedDagJWSResult, Schema } from './types';
export declare const SCHEMA_REF_ID = "ceramic://schemaReference";
export declare type CreatedDoc = {
    id: StreamRef;
    dependencies: Array<StreamRef>;
};
export declare type PublishedDocSet = {
    definitions: Record<string, string>;
    schemas: Record<string, string>;
    tiles: Record<string, string>;
};
export declare type DocSetData<T> = {
    docs: Record<string, T>;
    definitions: Array<string>;
    schemas: Array<string>;
};
export declare type SignedDocSet = DocSetData<Array<DagJWSResult>>;
export declare type EncodedSignedDocSet = DocSetData<Array<EncodedDagJWSResult>>;
declare type FieldCommon = {
    required?: boolean;
};
declare type FieldType = {
    type: 'boolean';
} | {
    type: 'integer';
} | {
    type: 'float';
} | {
    type: 'string';
} | {
    type: 'list';
    name: string;
} | {
    type: 'object';
    name: string;
} | {
    type: 'reference';
    name: string;
};
declare type Field = FieldCommon & FieldType;
declare type ObjectFields = Record<string, Field>;
declare type DocReference = {
    id: string;
    schema: string;
};
declare type GraphQLDocSetRecords = {
    index: Record<string, DocReference>;
    lists: Record<string, string>;
    nodes: Record<string, string>;
    objects: Record<string, ObjectFields>;
    references: Record<string, Array<string>>;
    roots: Record<string, DocReference>;
};
export declare class DocSet {
    _ceramic: CeramicApi;
    _docs: Record<string, Promise<TileDocument>>;
    _definitions: Record<string, Promise<CreatedDoc>>;
    _schemas: Record<string, Promise<CreatedDoc>>;
    _schemaAliases: Record<string, string>;
    _tiles: Record<string, Promise<CreatedDoc>>;
    constructor(ceramic: CeramicApi);
    loadCreated(created: Promise<CreatedDoc>): Promise<TileDocument>;
    loadDoc(streamID: StreamRef | string): Promise<TileDocument>;
    get definitions(): Array<string>;
    get schemas(): Array<string>;
    get tiles(): Array<string>;
    hasSchema(alias: string): boolean;
    getSchema(alias: string): Promise<CreatedDoc> | null;
    deleteSchema(alias: string): boolean;
    createSchema(name: string, schema: Schema, deps?: Array<Promise<StreamRef>>): Promise<CreatedDoc>;
    addSchema(schema: Schema, alias?: string): Promise<StreamRef>;
    useExistingSchema(id: StreamRef | string, alias?: string): Promise<StreamRef>;
    hasDefinition(alias: string): boolean;
    getDefinition(alias: string): Promise<CreatedDoc> | null;
    deleteDefinition(alias: string): boolean;
    createDefinition(alias: string, definition: Definition, deps?: Array<Promise<StreamRef>>): Promise<CreatedDoc>;
    addDefinition(definition: Definition, alias?: string): Promise<StreamRef>;
    hasTile(alias: string): boolean;
    getTile(alias: string): Promise<CreatedDoc> | null;
    deleteTile(alias: string): boolean;
    createTile<T extends Record<string, unknown>>(alias: string, contents: T, meta: Partial<StreamMetadata>, deps?: Array<Promise<StreamRef>>): Promise<CreatedDoc>;
    addTile<T extends Record<string, unknown>>(alias: string, contents: T, meta: Partial<StreamMetadata>): Promise<StreamRef>;
    toPublished(): Promise<PublishedDocSet>;
    toSigned(): Promise<SignedDocSet>;
    toSignedJSON(): Promise<EncodedSignedDocSet>;
    toGraphQLDocSetRecords(): Promise<GraphQLDocSetRecords>;
}
export declare function publishSignedDocSet(ceramic: CeramicApi, docSet: SignedDocSet): Promise<void>;
export declare function publishEncodedSignedDocSet(ceramic: CeramicApi, { docs, ...docSet }: EncodedSignedDocSet): Promise<void>;
export {};
