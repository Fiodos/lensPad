import { pascalCase, camelCase } from 'change-case';
import CID from 'cids';
import { fromString, toString } from 'uint8arrays';
import { TileDocument } from '@ceramicnetwork/stream-tile';
import { schemas as schemas$1 } from '@ceramicstudio/idx-constants';
import isEqual from 'fast-deep-equal';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import SecureSchema from 'ajv/lib/refs/json-schema-secure.json';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = /*#__PURE__*/createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

var $schema = "http://json-schema.org/draft-07/schema#";
var type = "object";
var title = "AlsoKnownAs";
var properties = {
	accounts: {
		type: "array",
		items: {
			$ref: "#/definitions/Account"
		}
	}
};
var additionalProperties = false;
var required = [
	"accounts"
];
var definitions = {
	Attestation: {
		type: "object",
		properties: {
			"did-jwt": {
				type: "string",
				maxLength: 1000
			},
			"did-jwt-vc": {
				type: "string",
				maxLength: 1000
			}
		}
	},
	Account: {
		type: "object",
		properties: {
			protocol: {
				type: "string",
				maxLength: 50
			},
			host: {
				type: "string",
				maxLength: 150
			},
			id: {
				type: "string",
				maxLength: 450
			},
			claim: {
				type: "string",
				maxLength: 450
			},
			attestations: {
				type: "array",
				items: {
					$ref: "#/definitions/Attestation"
				}
			}
		},
		required: [
			"protocol",
			"id"
		]
	}
};
var AlsoKnownAs = {
	$schema: $schema,
	type: type,
	title: title,
	properties: properties,
	additionalProperties: additionalProperties,
	required: required,
	definitions: definitions
};

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var title$1 = "BasicProfile";
var type$1 = "object";
var properties$1 = {
	name: {
		type: "string",
		maxLength: 150
	},
	image: {
		$ref: "#/definitions/imageSources"
	},
	description: {
		type: "string",
		maxLength: 420
	},
	emoji: {
		type: "string",
		maxLength: 2
	},
	background: {
		$ref: "#/definitions/imageSources"
	},
	birthDate: {
		type: "string",
		format: "date",
		maxLength: 10
	},
	url: {
		type: "string",
		maxLength: 240
	},
	gender: {
		type: "string",
		maxLength: 42
	},
	homeLocation: {
		type: "string",
		maxLength: 140
	},
	residenceCountry: {
		type: "string",
		pattern: "^[A-Z]{2}$",
		maxLength: 2
	},
	nationalities: {
		type: "array",
		minItems: 1,
		items: {
			type: "string",
			pattern: "^[A-Z]{2}$",
			maxItems: 5
		}
	},
	affiliations: {
		type: "array",
		items: {
			type: "string",
			maxLength: 140
		}
	}
};
var definitions$1 = {
	IPFSUrl: {
		type: "string",
		pattern: "^ipfs://.+",
		maxLength: 150
	},
	positiveInteger: {
		type: "integer",
		minimum: 1
	},
	imageMetadata: {
		type: "object",
		properties: {
			src: {
				$ref: "#/definitions/IPFSUrl"
			},
			mimeType: {
				type: "string",
				maxLength: 50
			},
			width: {
				$ref: "#/definitions/positiveInteger"
			},
			height: {
				$ref: "#/definitions/positiveInteger"
			},
			size: {
				$ref: "#/definitions/positiveInteger"
			}
		},
		required: [
			"src",
			"mimeType",
			"width",
			"height"
		]
	},
	imageSources: {
		type: "object",
		properties: {
			original: {
				$ref: "#/definitions/imageMetadata"
			},
			alternatives: {
				type: "array",
				items: {
					$ref: "#/definitions/imageMetadata"
				}
			}
		},
		required: [
			"original"
		]
	}
};
var BasicProfile = {
	$schema: $schema$1,
	title: title$1,
	type: type$1,
	properties: properties$1,
	definitions: definitions$1
};

var $schema$2 = "http://json-schema.org/draft-07/schema#";
var type$2 = "object";
var title$2 = "CryptoAccountLinks";
var patternProperties = {
	"^[a-zA-Z0-9]{1,63}@[-a-zA-Z0-9]{3,16}:[-a-zA-Z0-9]{1,47}": {
		type: "string",
		pattern: "^ceramic://.+",
		maxLength: 1024
	}
};
var propertyNames = {
	maxLength: 1024
};
var additionalProperties$1 = false;
var CryptoAccounts = {
	$schema: $schema$2,
	type: type$2,
	title: title$2,
	patternProperties: patternProperties,
	propertyNames: propertyNames,
	additionalProperties: additionalProperties$1
};

var $schema$3 = "http://json-schema.org/draft-07/schema#";
var title$3 = "Definition";
var type$3 = "object";
var properties$2 = {
	name: {
		type: "string",
		maxLength: 150
	},
	schema: {
		$ref: "#/definitions/CeramicDocId"
	},
	description: {
		type: "string",
		maxLength: 420
	},
	url: {
		type: "string",
		maxLength: 240
	},
	config: {
		type: "object"
	}
};
var definitions$2 = {
	CeramicDocId: {
		type: "string",
		pattern: "^ceramic://.+(\\?version=.+)?",
		maxLength: 150
	}
};
var required$1 = [
	"name",
	"description",
	"schema"
];
var DefinitionSchema = {
	$schema: $schema$3,
	title: title$3,
	type: type$3,
	properties: properties$2,
	definitions: definitions$2,
	required: required$1
};

var $schema$4 = "http://json-schema.org/draft-07/schema#";
var type$4 = "object";
var title$4 = "IdentityIndex";
var additionalProperties$2 = {
	$ref: "#/definitions/CeramicDocId"
};
var definitions$3 = {
	CeramicDocId: {
		type: "string",
		pattern: "^ceramic://.+(\\?version=.+)?",
		maxLength: 150
	}
};
var IdentityIndex = {
	$schema: $schema$4,
	type: type$4,
	title: title$4,
	additionalProperties: additionalProperties$2,
	definitions: definitions$3
};

var $schema$5 = "http://json-schema.org/draft-07/schema#";
var definitions$4 = {
	JWE: {
		title: "JWE",
		type: "object",
		properties: {
			"protected": {
				type: "string"
			},
			iv: {
				type: "string"
			},
			ciphertext: {
				type: "string"
			},
			tag: {
				type: "string"
			},
			aad: {
				type: "string"
			},
			recipients: {
				type: "array",
				items: {
					type: "object",
					properties: {
						header: {
							type: "object"
						},
						encrypted_key: {
							type: "string"
						}
					},
					required: [
						"header",
						"encrypted_key"
					]
				}
			}
		},
		required: [
			"protected",
			"iv",
			"ciphertext",
			"tag"
		]
	},
	WrappedJWE: {
		type: "object",
		additionalProperties: false,
		properties: {
			jwe: {
				$ref: "#/definitions/JWE"
			}
		}
	},
	AuthData: {
		type: "object",
		additionalProperties: false,
		properties: {
			id: {
				$ref: "#/definitions/WrappedJWE"
			},
			pub: {
				type: "string"
			},
			data: {
				$ref: "#/definitions/WrappedJWE"
			}
		}
	}
};
var type$5 = "object";
var additionalProperties$3 = false;
var properties$3 = {
	authMap: {
		type: "object",
		additionalProperties: {
			$ref: "#/definitions/AuthData"
		}
	},
	pastSeeds: {
		type: "array",
		items: {
			$ref: "#/definitions/JWE"
		}
	}
};
var ThreeIdKeychain = {
	$schema: $schema$5,
	definitions: definitions$4,
	type: type$5,
	additionalProperties: additionalProperties$3,
	properties: properties$3
};



var schemas = {
  __proto__: null,
  AlsoKnownAs: AlsoKnownAs,
  BasicProfile: BasicProfile,
  CryptoAccounts: CryptoAccounts,
  Definition: DefinitionSchema,
  IdentityIndex: IdentityIndex,
  ThreeIdKeychain: ThreeIdKeychain
};

function docIDToString(id) {
  return typeof id === 'string' ? id : id.toString();
}
function applyMap(inputs, callFunc) {
  return Object.entries(inputs).reduce(function (acc, _ref) {
    var key = _ref[0],
        value = _ref[1];
    acc[key] = callFunc(value);
    return acc;
  }, {});
}
function promiseMap(_x, _x2) {
  return _promiseMap.apply(this, arguments);
}

function _promiseMap() {
  _promiseMap = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(inputs, callFunc) {
    var results;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return Promise.all(Object.values(inputs).map(function (value) {
              return callFunc(value);
            }));

          case 2:
            results = _context.sent;
            return _context.abrupt("return", Object.keys(inputs).reduce(function (acc, key, i) {
              acc[key] = results[i];
              return acc;
            }, {}));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _promiseMap.apply(this, arguments);
}

function signTile(_x, _x2, _x3) {
  return _signTile.apply(this, arguments);
}

function _signTile() {
  _signTile = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(did, data, schema) {
    var header;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (did.authenticated) {
              _context.next = 2;
              break;
            }

            throw new Error('DID must be authenticated');

          case 2:
            header = {
              controllers: [did.id],
              schema: schema ? docIDToString(schema) : undefined
            };
            _context.next = 5;
            return did.createDagJWS({
              data: data,
              doctype: 'tile',
              header: header
            }, {
              did: did.id
            });

          case 5:
            return _context.abrupt("return", _context.sent);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _signTile.apply(this, arguments);
}

function signIDXDefinitions(_x4, _x5, _x6) {
  return _signIDXDefinitions.apply(this, arguments);
}

function _signIDXDefinitions() {
  _signIDXDefinitions = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(did, definitionSchema, definitions) {
    var schema;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            schema = docIDToString(definitionSchema);
            _context3.next = 3;
            return promiseMap(definitions, /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(definition) {
                return runtime_1.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return signTile(did, definition, schema);

                      case 2:
                        _context2.t0 = _context2.sent;
                        return _context2.abrupt("return", [_context2.t0]);

                      case 4:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function (_x8) {
                return _ref.apply(this, arguments);
              };
            }());

          case 3:
            return _context3.abrupt("return", _context3.sent);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _signIDXDefinitions.apply(this, arguments);
}

function signIDXSchemas(_x7) {
  return _signIDXSchemas.apply(this, arguments);
}

function _signIDXSchemas() {
  _signIDXSchemas = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(did) {
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return promiseMap(schemas, /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(schema) {
                return runtime_1.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return signTile(did, schema);

                      case 2:
                        _context4.t0 = _context4.sent;
                        return _context4.abrupt("return", [_context4.t0]);

                      case 4:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x9) {
                return _ref2.apply(this, arguments);
              };
            }());

          case 2:
            return _context5.abrupt("return", _context5.sent);

          case 3:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _signIDXSchemas.apply(this, arguments);
}

function createIDXDefinitions(schemas) {
  return {
    alsoKnownAs: {
      name: 'Also Known As',
      description: 'Also Known As is a data set that stores a list of accounts that are publicly linked to the users DID',
      schema: schemas.AlsoKnownAs
    },
    basicProfile: {
      name: 'Basic Profile',
      description: 'Basic profile information for a DID',
      schema: schemas.BasicProfile
    },
    cryptoAccounts: {
      name: 'Crypto Accounts',
      description: 'Crypto accounts linked to your DID',
      schema: schemas.CryptoAccounts
    },
    threeIdKeychain: {
      name: '3ID Keychain',
      description: 'Key data for 3ID',
      schema: schemas.ThreeIdKeychain
    }
  };
}
function createIDXSignedDefinitions(_x, _x2) {
  return _createIDXSignedDefinitions.apply(this, arguments);
}

function _createIDXSignedDefinitions() {
  _createIDXSignedDefinitions = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(did, schemas) {
    var definitions;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            definitions = createIDXDefinitions(schemas);
            _context.next = 3;
            return signIDXDefinitions(did, schemas.Definition, definitions);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createIDXSignedDefinitions.apply(this, arguments);
}

function decodeDagJWS(_ref) {
  var payload = _ref.payload,
      signatures = _ref.signatures,
      link = _ref.link;
  return {
    payload: payload,
    signatures: signatures,
    link: link ? new CID(link) : undefined
  };
}
function encodeDagJWS(_ref2) {
  var payload = _ref2.payload,
      signatures = _ref2.signatures,
      link = _ref2.link;
  return {
    payload: payload,
    signatures: signatures,
    link: link == null ? void 0 : link.toString()
  };
}
function decodeDagJWSResult(_ref3) {
  var jws = _ref3.jws,
      linkedBlock = _ref3.linkedBlock;
  return {
    jws: decodeDagJWS(jws),
    linkedBlock: fromString(linkedBlock, 'base64pad')
  };
}
function encodeDagJWSResult(_ref4) {
  var jws = _ref4.jws,
      linkedBlock = _ref4.linkedBlock;
  return {
    jws: encodeDagJWS(jws),
    linkedBlock: toString(linkedBlock, 'base64pad')
  };
}
function decodeSignedMap(data) {
  return applyMap(data, function (records) {
    return records.map(decodeDagJWSResult);
  });
}
function encodeSignedMap(data) {
  return applyMap(data, function (records) {
    return records.map(encodeDagJWSResult);
  });
}

var alsoKnownAs = [
	{
		jws: {
			payload: "AXESIOWmE0CF2MHEz0PmBVBOkCvzCVXNE5Mg-894RRaXaZJe",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "GurUQxUEzBdidKjlPdv09NLD-aG787p47ghUMW2PA5av49soVKe3I4xntq4OzXHXm-weLzuMFUFxkURvgUDuAA"
				}
			],
			link: "bafyreihfuyjubboyyhcm6q7gavie5ebl6mevltitsmqpxt3yiuljo2msly"
		},
		linkedBlock: "o2RkYXRho2RuYW1lbUFsc28gS25vd24gQXNmc2NoZW1heEtjZXJhbWljOi8vazN5NTJsN3FidjFmcnlvanQ4bjhjdzJrMDRwOXdwNjdseTU5aXdxczY1ZGVqc281NjZmaWo1d3NkcmI4NzF5aW9rZGVzY3JpcHRpb254ZEFsc28gS25vd24gQXMgaXMgYSBkYXRhIHNldCB0aGF0IHN0b3JlcyBhIGxpc3Qgb2YgYWNjb3VudHMgdGhhdCBhcmUgcHVibGljbHkgbGlua2VkIHRvIHRoZSB1c2VycyBESURmaGVhZGVyomZzY2hlbWF4S2NlcmFtaWM6Ly9rM3k1Mmw3cWJ2MWZyeTFmcDRzMG53ZGFyaDB2YWh1c2FycHBvc2dldnkwcGVtaXlreW1kMm9yZDZzd3RoYXJjd2tjb250cm9sbGVyc4F4OGRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBZ2RvY3R5cGVkdGlsZQ=="
	}
];
var basicProfile = [
	{
		jws: {
			payload: "AXESIHQlyxvLYuiHGvjCREWnS0HxQV6z7lfPRe4mRdViHjWU",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "619cILy5j-zkYwz0pJ2cYnPnVqmYf6YJcuqxcLoaRqvCL341HOoTm0siEOG_Jmu1alT_UUuah1dlrqubgIe1BA"
				}
			],
			link: "bafyreiduexfrxs3c5cdrv6gcirc2os2b6fav5m7ok7hul3rgixkwehrvsq"
		},
		linkedBlock: "o2RkYXRho2RuYW1lbUJhc2ljIFByb2ZpbGVmc2NoZW1heEtjZXJhbWljOi8vazN5NTJsN3FidjFmcnh0NzA2Z3Fmem1xNmNicWRrcHR6azh1dWRhcnlobGtmNmx5OXZ4MjFocXU0cjZrMWpxaW9rZGVzY3JpcHRpb254I0Jhc2ljIHByb2ZpbGUgaW5mb3JtYXRpb24gZm9yIGEgRElEZmhlYWRlcqJmc2NoZW1heEtjZXJhbWljOi8vazN5NTJsN3FidjFmcnkxZnA0czBud2RhcmgwdmFodXNhcnBwb3NnZXZ5MHBlbWl5a3ltZDJvcmQ2c3d0aGFyY3drY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QWdkb2N0eXBlZHRpbGU="
	}
];
var cryptoAccounts = [
	{
		jws: {
			payload: "AXESIILyy1_0_U8dXhlxpyWOMxBDKion3W2mMbfS5WmuL-Xb",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "IKbedepBBpEdE9DKx6WjCYYyFdo9mfgv422_vLlT8vusBGM-P7YiEn6t3iYHrMi-dzrnE4Lp8wY0aqhFnDuWCA"
				}
			],
			link: "bafyreiec6lfv75h5j4ov4glru4sy4myqimvcuj65nwtddn6s4vu24l7f3m"
		},
		linkedBlock: "o2RkYXRho2RuYW1lb0NyeXB0byBBY2NvdW50c2ZzY2hlbWF4S2NlcmFtaWM6Ly9rM3k1Mmw3cWJ2MWZyeXB1c3NqYnVycWc0ZnlreXl5Y2Z1MHA5em5jNzVsdjJ0NWNnNHhhc2xoYWdrZDdoN21rZ2tkZXNjcmlwdGlvbngiQ3J5cHRvIGFjY291bnRzIGxpbmtlZCB0byB5b3VyIERJRGZoZWFkZXKiZnNjaGVtYXhLY2VyYW1pYzovL2szeTUybDdxYnYxZnJ5MWZwNHMwbndkYXJoMHZhaHVzYXJwcG9zZ2V2eTBwZW1peWt5bWQyb3JkNnN3dGhhcmN3a2NvbnRyb2xsZXJzgXg4ZGlkOmtleTp6Nk1rc05ZRTZXdE1aM1dMYlB3Y3A5R203ZFQ3SjNEc05QOGF1UU5uUHBRQnUzN0FnZG9jdHlwZWR0aWxl"
	}
];
var threeIdKeychain = [
	{
		jws: {
			payload: "AXESIGyI_q2lZeGlUOHKcp--mfAyATQxgGxLVs6czea19pDb",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "Ozhsz077CUps_NHDd_8g4OD3lbysXtJQDZWTpzeBfwjZ5mqDv_uvPPYkhJuld6N0hWTSBi7y6K2iNHYlDdfqCA"
				}
			],
			link: "bafyreidmrd7k3jlf4gsvbyokokp35gpqgiatimmanrfvntu4zxtll5uq3m"
		},
		linkedBlock: "o2RkYXRho2RuYW1lbDNJRCBLZXljaGFpbmZzY2hlbWF4S2NlcmFtaWM6Ly9rM3k1Mmw3cWJ2MWZyeGlvZGZvNmYyNXdvY2I4eno2MHl3cXc0c3FjcHJzMjZxeDFxeDQ2N2w0eWJ4cGx5YnZnZ2tkZXNjcmlwdGlvbnBLZXkgZGF0YSBmb3IgM0lEZmhlYWRlcqJmc2NoZW1heEtjZXJhbWljOi8vazN5NTJsN3FidjFmcnkxZnA0czBud2RhcmgwdmFodXNhcnBwb3NnZXZ5MHBlbWl5a3ltZDJvcmQ2c3d0aGFyY3drY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QWdkb2N0eXBlZHRpbGU="
	}
];
var encodedDefinitions = {
	alsoKnownAs: alsoKnownAs,
	basicProfile: basicProfile,
	cryptoAccounts: cryptoAccounts,
	threeIdKeychain: threeIdKeychain
};

var AlsoKnownAs$1 = [
	{
		jws: {
			payload: "AXESIALdl9Z9fNLBS6NfkZ2JRIClBQFb0cIi2rVwS1Kie2k1",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "bg4CcLmHGYPYsRvl_EObk2HgtOjijDNBJrOzupI2NMT-n_3Wj4GaUn83wA2IqTtql5uZRpgBYqxOjGdH4GB6CA"
				}
			],
			link: "bafyreiac3wl5m7l42lauxi27sgoysreauucqcw6ryirnvnlqjnjke63jgu"
		},
		linkedBlock: "o2RkYXRhp2R0eXBlZm9iamVjdGV0aXRsZWtBbHNvS25vd25Bc2ckc2NoZW1heCdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNocmVxdWlyZWSBaGFjY291bnRzanByb3BlcnRpZXOhaGFjY291bnRzomR0eXBlZWFycmF5ZWl0ZW1zoWQkcmVmdSMvZGVmaW5pdGlvbnMvQWNjb3VudGtkZWZpbml0aW9uc6JnQWNjb3VudKNkdHlwZWZvYmplY3RocmVxdWlyZWSCaHByb3RvY29sYmlkanByb3BlcnRpZXOlYmlkomR0eXBlZnN0cmluZ2ltYXhMZW5ndGgZAcJkaG9zdKJkdHlwZWZzdHJpbmdpbWF4TGVuZ3RoGJZlY2xhaW2iZHR5cGVmc3RyaW5naW1heExlbmd0aBkBwmhwcm90b2NvbKJkdHlwZWZzdHJpbmdpbWF4TGVuZ3RoGDJsYXR0ZXN0YXRpb25zomR0eXBlZWFycmF5ZWl0ZW1zoWQkcmVmeBkjL2RlZmluaXRpb25zL0F0dGVzdGF0aW9ua0F0dGVzdGF0aW9uomR0eXBlZm9iamVjdGpwcm9wZXJ0aWVzomdkaWQtand0omR0eXBlZnN0cmluZ2ltYXhMZW5ndGgZA+hqZGlkLWp3dC12Y6JkdHlwZWZzdHJpbmdpbWF4TGVuZ3RoGQPodGFkZGl0aW9uYWxQcm9wZXJ0aWVz9GZoZWFkZXKiZnNjaGVtYfdrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QWdkb2N0eXBlZHRpbGU="
	}
];
var BasicProfile$1 = [
	{
		jws: {
			payload: "AXESIMy4lYCUWSpzFW5jKQ0mYJOQ67EQnv5Exuv3F599h-et",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "yeEnzWKALkvTn_X7wjgL3ldLW8I8vWANs5QZmqI6PGbU5AJl12eIuWyID-mRPuGF9flovtGNX1P-qKkc6Y8JBA"
				}
			],
			link: "bafyreigmxckybfczfjzrk3tdfegsmyetsdv3cee67zcmn27xc6px3b7hvu"
		},
		linkedBlock: "o2RkYXRhpWR0eXBlZm9iamVjdGV0aXRsZWxCYXNpY1Byb2ZpbGVnJHNjaGVtYXgnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjanByb3BlcnRpZXOsY3VybKJkdHlwZWZzdHJpbmdpbWF4TGVuZ3RoGPBkbmFtZaJkdHlwZWZzdHJpbmdpbWF4TGVuZ3RoGJZlZW1vammiZHR5cGVmc3RyaW5naW1heExlbmd0aAJlaW1hZ2WhZCRyZWZ4GiMvZGVmaW5pdGlvbnMvaW1hZ2VTb3VyY2VzZmdlbmRlcqJkdHlwZWZzdHJpbmdpbWF4TGVuZ3RoGCppYmlydGhEYXRlo2R0eXBlZnN0cmluZ2Zmb3JtYXRkZGF0ZWltYXhMZW5ndGgKamJhY2tncm91bmShZCRyZWZ4GiMvZGVmaW5pdGlvbnMvaW1hZ2VTb3VyY2Vza2Rlc2NyaXB0aW9uomR0eXBlZnN0cmluZ2ltYXhMZW5ndGgZAaRsYWZmaWxpYXRpb25zomR0eXBlZWFycmF5ZWl0ZW1zomR0eXBlZnN0cmluZ2ltYXhMZW5ndGgYjGxob21lTG9jYXRpb26iZHR5cGVmc3RyaW5naW1heExlbmd0aBiMbW5hdGlvbmFsaXRpZXOjZHR5cGVlYXJyYXllaXRlbXOjZHR5cGVmc3RyaW5nZ3BhdHRlcm5qXltBLVpdezJ9JGhtYXhJdGVtcwVobWluSXRlbXMBcHJlc2lkZW5jZUNvdW50cnmjZHR5cGVmc3RyaW5nZ3BhdHRlcm5qXltBLVpdezJ9JGltYXhMZW5ndGgCa2RlZmluaXRpb25zpGdJUEZTVXJso2R0eXBlZnN0cmluZ2dwYXR0ZXJual5pcGZzOi8vLitpbWF4TGVuZ3RoGJZsaW1hZ2VTb3VyY2Vzo2R0eXBlZm9iamVjdGhyZXF1aXJlZIFob3JpZ2luYWxqcHJvcGVydGllc6Job3JpZ2luYWyhZCRyZWZ4GyMvZGVmaW5pdGlvbnMvaW1hZ2VNZXRhZGF0YWxhbHRlcm5hdGl2ZXOiZHR5cGVlYXJyYXllaXRlbXOhZCRyZWZ4GyMvZGVmaW5pdGlvbnMvaW1hZ2VNZXRhZGF0YW1pbWFnZU1ldGFkYXRho2R0eXBlZm9iamVjdGhyZXF1aXJlZIRjc3JjaG1pbWVUeXBlZXdpZHRoZmhlaWdodGpwcm9wZXJ0aWVzpWNzcmOhZCRyZWZ1Iy9kZWZpbml0aW9ucy9JUEZTVXJsZHNpemWhZCRyZWZ4HSMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyZXdpZHRooWQkcmVmeB0jL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlcmZoZWlnaHShZCRyZWZ4HSMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyaG1pbWVUeXBlomR0eXBlZnN0cmluZ2ltYXhMZW5ndGgYMm9wb3NpdGl2ZUludGVnZXKiZHR5cGVnaW50ZWdlcmdtaW5pbXVtAWZoZWFkZXKiZnNjaGVtYfdrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QWdkb2N0eXBlZHRpbGU="
	}
];
var CryptoAccounts$1 = [
	{
		jws: {
			payload: "AXESIF-4Olz6gzTYrKPZj_7buHaUsueU-P0K67cq6kHlJphd",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "WMNOLmFwYUcYg-dhzg_zkFYit2j7hdYY4_NvcRy_4q_CJmfj8WOxTeHRQ1HqdXkXVycg_Q4JmtqUG992Cdf2CA"
				}
			],
			link: "bafyreic7xa5fz6udgtmkzi6zr77nxodwsszopfhy7ufoxnzk5ja6kjuylu"
		},
		linkedBlock: "o2RkYXRhpmR0eXBlZm9iamVjdGV0aXRsZXJDcnlwdG9BY2NvdW50TGlua3NnJHNjaGVtYXgnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjbXByb3BlcnR5TmFtZXOhaW1heExlbmd0aBkEAHFwYXR0ZXJuUHJvcGVydGllc6F4OF5bYS16QS1aMC05XXsxLDYzfUBbLWEtekEtWjAtOV17MywxNn06Wy1hLXpBLVowLTldezEsNDd9o2R0eXBlZnN0cmluZ2dwYXR0ZXJubV5jZXJhbWljOi8vLitpbWF4TGVuZ3RoGQQAdGFkZGl0aW9uYWxQcm9wZXJ0aWVz9GZoZWFkZXKiZnNjaGVtYfdrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QWdkb2N0eXBlZHRpbGU="
	}
];
var Definition = [
	{
		jws: {
			payload: "AXESIGVBGu8EHXq5fxC16J4MwEPBCfrWq1bsZWQP2F_WWhT0",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "hvv_KWbyYbg7ZP8PQeJxPjHnlAg1VKtPjVa6zXwMq9pug96qGcXFQi5XUAl30RH4QYOHl8Gpv4uZczWxAJllAg"
				}
			],
			link: "bafyreidfieno6ba5pk4x6efv5cpazqcdyee7vvvlk3wgkzap3bp5mwqu6q"
		},
		linkedBlock: "o2RkYXRhpmR0eXBlZm9iamVjdGV0aXRsZWpEZWZpbml0aW9uZyRzY2hlbWF4J2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI2hyZXF1aXJlZINkbmFtZWtkZXNjcmlwdGlvbmZzY2hlbWFqcHJvcGVydGllc6VjdXJsomR0eXBlZnN0cmluZ2ltYXhMZW5ndGgY8GRuYW1lomR0eXBlZnN0cmluZ2ltYXhMZW5ndGgYlmZjb25maWehZHR5cGVmb2JqZWN0ZnNjaGVtYaFkJHJlZngaIy9kZWZpbml0aW9ucy9DZXJhbWljRG9jSWRrZGVzY3JpcHRpb26iZHR5cGVmc3RyaW5naW1heExlbmd0aBkBpGtkZWZpbml0aW9uc6FsQ2VyYW1pY0RvY0lko2R0eXBlZnN0cmluZ2dwYXR0ZXJueBxeY2VyYW1pYzovLy4rKFw/dmVyc2lvbj0uKyk/aW1heExlbmd0aBiWZmhlYWRlcqJmc2NoZW1h92tjb250cm9sbGVyc4F4OGRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBZ2RvY3R5cGVkdGlsZQ=="
	}
];
var IdentityIndex$1 = [
	{
		jws: {
			payload: "AXESIKO29HNjXsFTO9Bbs5VTTGqJUPZ9Aoic83L6G0ziXp48",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "R-VH5EwcOsvd3Txsl4Pjw-QSobjiNJuQVPWrbubyX6uIbe2SRupKx5od0z2agdeVnglt9L9mHiOqlRGgI7WNDQ"
				}
			],
			link: "bafyreifdw32hgy26yfjtxuc3wokvgtdkrfipm7icrcopg4x2dngoexu6hq"
		},
		linkedBlock: "o2RkYXRhpWR0eXBlZm9iamVjdGV0aXRsZW1JZGVudGl0eUluZGV4ZyRzY2hlbWF4J2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI2tkZWZpbml0aW9uc6FsQ2VyYW1pY0RvY0lko2R0eXBlZnN0cmluZ2dwYXR0ZXJueBxeY2VyYW1pYzovLy4rKFw/dmVyc2lvbj0uKyk/aW1heExlbmd0aBiWdGFkZGl0aW9uYWxQcm9wZXJ0aWVzoWQkcmVmeBojL2RlZmluaXRpb25zL0NlcmFtaWNEb2NJZGZoZWFkZXKiZnNjaGVtYfdrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QWdkb2N0eXBlZHRpbGU="
	}
];
var ThreeIdKeychain$1 = [
	{
		jws: {
			payload: "AXESIDpfdAEsNb76jO9057sDPODcniYXUcxAdlhQXEqr4BBB",
			signatures: [
				{
					"protected": "eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa3NOWUU2V3RNWjNXTGJQd2NwOUdtN2RUN0ozRHNOUDhhdVFOblBwUUJ1MzdBI3o2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QSJ9",
					signature: "Zir2mHf-si2EIGZIMryci6V9hJxEHBLWesBVLzqkl5hlw0DyoBVvVpK5HN_QiozIMCbagPx2v1aLhKb_dNujDw"
				}
			],
			link: "bafyreib2l52aclbvx35iz33u465qgpha3spcmf2rzrahmwcqlrfkxyaqie"
		},
		linkedBlock: "o2RkYXRhpWR0eXBlZm9iamVjdGckc2NoZW1heCdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNqcHJvcGVydGllc6JnYXV0aE1hcKJkdHlwZWZvYmplY3R0YWRkaXRpb25hbFByb3BlcnRpZXOhZCRyZWZ2Iy9kZWZpbml0aW9ucy9BdXRoRGF0YWlwYXN0U2VlZHOiZHR5cGVlYXJyYXllaXRlbXOhZCRyZWZxIy9kZWZpbml0aW9ucy9KV0VrZGVmaW5pdGlvbnOjY0pXRaRkdHlwZWZvYmplY3RldGl0bGVjSldFaHJlcXVpcmVkhGlwcm90ZWN0ZWRiaXZqY2lwaGVydGV4dGN0YWdqcHJvcGVydGllc6ZiaXahZHR5cGVmc3RyaW5nY2FhZKFkdHlwZWZzdHJpbmdjdGFnoWR0eXBlZnN0cmluZ2lwcm90ZWN0ZWShZHR5cGVmc3RyaW5namNpcGhlcnRleHShZHR5cGVmc3RyaW5nanJlY2lwaWVudHOiZHR5cGVlYXJyYXllaXRlbXOjZHR5cGVmb2JqZWN0aHJlcXVpcmVkgmZoZWFkZXJtZW5jcnlwdGVkX2tleWpwcm9wZXJ0aWVzomZoZWFkZXKhZHR5cGVmb2JqZWN0bWVuY3J5cHRlZF9rZXmhZHR5cGVmc3RyaW5naEF1dGhEYXRho2R0eXBlZm9iamVjdGpwcm9wZXJ0aWVzo2JpZKFkJHJlZngYIy9kZWZpbml0aW9ucy9XcmFwcGVkSldFY3B1YqFkdHlwZWZzdHJpbmdkZGF0YaFkJHJlZngYIy9kZWZpbml0aW9ucy9XcmFwcGVkSldFdGFkZGl0aW9uYWxQcm9wZXJ0aWVz9GpXcmFwcGVkSldFo2R0eXBlZm9iamVjdGpwcm9wZXJ0aWVzoWNqd2WhZCRyZWZxIy9kZWZpbml0aW9ucy9KV0V0YWRkaXRpb25hbFByb3BlcnRpZXP0dGFkZGl0aW9uYWxQcm9wZXJ0aWVz9GZoZWFkZXKiZnNjaGVtYfdrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtzTllFNld0TVozV0xiUHdjcDlHbTdkVDdKM0RzTlA4YXVRTm5QcFFCdTM3QWdkb2N0eXBlZHRpbGU="
	}
];
var encodedSchemas = {
	AlsoKnownAs: AlsoKnownAs$1,
	BasicProfile: BasicProfile$1,
	CryptoAccounts: CryptoAccounts$1,
	Definition: Definition,
	IdentityIndex: IdentityIndex$1,
	ThreeIdKeychain: ThreeIdKeychain$1
};

var signedDefinitions = /*#__PURE__*/decodeSignedMap(encodedDefinitions);
var signedSchemas = /*#__PURE__*/decodeSignedMap(encodedSchemas);

var ajv = /*#__PURE__*/new Ajv({
  strict: false
});
addFormats(ajv); // Seems there is a type mismatch with ajv-formats

var validateDefinition = /*#__PURE__*/ajv.compile(DefinitionSchema);
function isValidDefinition(definition) {
  return validateDefinition(definition);
}
var validateSchemaSecure = /*#__PURE__*/ajv.compile(SecureSchema);
function isSecureSchema(schema) {
  ajv.compile(schema);
  return validateSchemaSecure(schema);
}

var PUBLISH_OPTS = {
  anchor: false,
  publish: false
};
function createTile(_x, _x2, _x3) {
  return _createTile.apply(this, arguments);
}

function _createTile() {
  _createTile = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(ceramic, content, metadata) {
    var doc;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (metadata === void 0) {
              metadata = {};
            }

            if (!(ceramic.did == null)) {
              _context.next = 3;
              break;
            }

            throw new Error('Ceramic instance is not authenticated');

          case 3:
            if (metadata.controllers == null || metadata.controllers.length === 0) {
              metadata.controllers = [ceramic.did.id];
            }

            _context.next = 6;
            return TileDocument.create(ceramic, content, metadata);

          case 6:
            doc = _context.sent;
            _context.next = 9;
            return ceramic.pin.add(doc.id);

          case 9:
            return _context.abrupt("return", doc);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createTile.apply(this, arguments);
}

function publishDoc(_x4, _x5) {
  return _publishDoc.apply(this, arguments);
}

function _publishDoc() {
  _publishDoc = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(ceramic, doc) {
    var loaded;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(doc.id == null)) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return createTile(ceramic, doc.content, {
              controllers: doc.controllers,
              schema: doc.schema ? docIDToString(doc.schema) : undefined
            });

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
            _context2.next = 6;
            return ceramic.loadStream(doc.id);

          case 6:
            loaded = _context2.sent;

            if (isEqual(loaded.content, doc.content)) {
              _context2.next = 10;
              break;
            }

            _context2.next = 10;
            return loaded.update(doc.content);

          case 10:
            return _context2.abrupt("return", loaded);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _publishDoc.apply(this, arguments);
}

function createDefinition(_x6, _x7) {
  return _createDefinition.apply(this, arguments);
}

function _createDefinition() {
  _createDefinition = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(ceramic, definition) {
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (isValidDefinition(definition)) {
              _context3.next = 2;
              break;
            }

            throw new Error('Invalid definition');

          case 2:
            _context3.next = 4;
            return createTile(ceramic, definition, {
              schema: schemas$1.Definition
            });

          case 4:
            return _context3.abrupt("return", _context3.sent);

          case 5:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _createDefinition.apply(this, arguments);
}

function updateDefinition(_x8, _x9) {
  return _updateDefinition.apply(this, arguments);
}

function _updateDefinition() {
  _updateDefinition = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(ceramic, doc) {
    var loaded;
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return ceramic.loadStream(doc.id);

          case 2:
            loaded = _context4.sent;

            if (!(loaded.metadata.schema !== schemas$1.Definition)) {
              _context4.next = 5;
              break;
            }

            throw new Error('Document is not a valid Definition');

          case 5:
            if (isEqual(loaded.content, doc.content)) {
              _context4.next = 9;
              break;
            }

            _context4.next = 8;
            return loaded.update(doc.content);

          case 8:
            return _context4.abrupt("return", true);

          case 9:
            return _context4.abrupt("return", false);

          case 10:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _updateDefinition.apply(this, arguments);
}

function publishCommits(_x10, _x11) {
  return _publishCommits.apply(this, arguments);
}

function _publishCommits() {
  _publishCommits = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(ceramic, _ref) {
    var genesis, updates, doc, _iterator, _step, commit;

    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            genesis = _ref[0], updates = _ref.slice(1);
            _context5.next = 3;
            return TileDocument.createFromGenesis(ceramic, genesis, PUBLISH_OPTS);

          case 3:
            doc = _context5.sent;
            _context5.next = 6;
            return ceramic.pin.add(doc.id);

          case 6:
            _iterator = _createForOfIteratorHelperLoose(updates);

          case 7:
            if ((_step = _iterator()).done) {
              _context5.next = 13;
              break;
            }

            commit = _step.value;
            _context5.next = 11;
            return ceramic.applyCommit(doc.id, commit, PUBLISH_OPTS);

          case 11:
            _context5.next = 7;
            break;

          case 13:
            return _context5.abrupt("return", doc);

          case 14:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _publishCommits.apply(this, arguments);
}

function publishSchema(_x12, _x13) {
  return _publishSchema.apply(this, arguments);
}

function _publishSchema() {
  _publishSchema = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(ceramic, doc) {
    return runtime_1.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (isSecureSchema(doc.content)) {
              _context6.next = 2;
              break;
            }

            throw new Error("Schema " + doc.name + " is not secure");

          case 2:
            _context6.next = 4;
            return publishDoc(ceramic, doc);

          case 4:
            return _context6.abrupt("return", _context6.sent);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _publishSchema.apply(this, arguments);
}

function publishSignedMap(_x14, _x15) {
  return _publishSignedMap.apply(this, arguments);
}

function _publishSignedMap() {
  _publishSignedMap = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(ceramic, signed) {
    return runtime_1.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return promiseMap(signed, /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(commits) {
                return runtime_1.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        _context7.next = 2;
                        return publishCommits(ceramic, commits);

                      case 2:
                        return _context7.abrupt("return", _context7.sent);

                      case 3:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));

              return function (_x21) {
                return _ref2.apply(this, arguments);
              };
            }());

          case 2:
            return _context8.abrupt("return", _context8.sent);

          case 3:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _publishSignedMap.apply(this, arguments);
}

function publishIDXSignedDefinitions(_x16, _x17) {
  return _publishIDXSignedDefinitions.apply(this, arguments);
}

function _publishIDXSignedDefinitions() {
  _publishIDXSignedDefinitions = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(ceramic, definitions) {
    var signedMap;
    return runtime_1.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (definitions === void 0) {
              definitions = signedDefinitions;
            }

            _context9.next = 3;
            return publishSignedMap(ceramic, definitions);

          case 3:
            signedMap = _context9.sent;
            return _context9.abrupt("return", Object.entries(signedMap).reduce(function (acc, _ref3) {
              var key = _ref3[0],
                  doc = _ref3[1];
              acc[key] = doc.id.toString();
              return acc;
            }, {}));

          case 5:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _publishIDXSignedDefinitions.apply(this, arguments);
}

function publishIDXSignedSchemas(_x18, _x19) {
  return _publishIDXSignedSchemas.apply(this, arguments);
}

function _publishIDXSignedSchemas() {
  _publishIDXSignedSchemas = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(ceramic, schemas) {
    var signedMap;
    return runtime_1.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (schemas === void 0) {
              schemas = signedSchemas;
            }

            _context10.next = 3;
            return publishSignedMap(ceramic, schemas);

          case 3:
            signedMap = _context10.sent;
            return _context10.abrupt("return", Object.entries(signedMap).reduce(function (acc, _ref4) {
              var key = _ref4[0],
                  doc = _ref4[1];
              acc[key] = doc.commitId.toUrl();
              return acc;
            }, {}));

          case 5:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _publishIDXSignedSchemas.apply(this, arguments);
}

function publishIDXConfig(_x20) {
  return _publishIDXConfig.apply(this, arguments);
}

function _publishIDXConfig() {
  _publishIDXConfig = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(ceramic) {
    var _yield$Promise$all, definitions, schemas;

    return runtime_1.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return Promise.all([publishIDXSignedDefinitions(ceramic), publishIDXSignedSchemas(ceramic)]);

          case 2:
            _yield$Promise$all = _context11.sent;
            definitions = _yield$Promise$all[0];
            schemas = _yield$Promise$all[1];
            return _context11.abrupt("return", {
              definitions: definitions,
              schemas: schemas
            });

          case 6:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _publishIDXConfig.apply(this, arguments);
}

var _excluded = ["docs"],
    _excluded2 = ["docs"];
var SCHEMA_REF_ID = 'ceramic://schemaReference'; // Add a JSON schema to the provided records based on its type

function addSchema(records, schema, options) {
  var _options$name;

  var providedTitle = (_options$name = options.name) != null ? _options$name : schema.title;

  if (providedTitle == null) {
    throw new Error('Schema must have a title');
  }

  var title = pascalCase(providedTitle);
  var name = title.startsWith(options.prefix) ? title : options.prefix + title;

  if (schema.type === 'array' && schema.items != null) {
    records.lists[name] = addSchema(records, schema.items, {
      prefix: name
    });
  } else if (schema.type === 'object' && schema.properties != null) {
    if (schema.$id === SCHEMA_REF_ID) {
      var ref = schema.properties.schema;

      if (ref != null) {
        if (ref["enum"] != null) {
          records.references[name] = ref["enum"];
        } else if (typeof ref["const"] === 'string') {
          records.references[name] = [ref["const"]];
        }
      }
    } else {
      var _schema$required;

      var requiredProps = (_schema$required = schema.required) != null ? _schema$required : [];
      records.objects[name] = Object.entries(schema.properties).reduce(function (acc, _ref) {
        var _value$title;

        var key = _ref[0],
            value = _ref[1];
        var prop = camelCase(key);
        var opts = {
          name: (_value$title = value.title) != null ? _value$title : key,
          prefix: name
        };
        var required = requiredProps.includes(key);

        if (value.type === 'array') {
          acc[prop] = {
            required: required,
            type: 'list',
            name: addSchema(records, value, opts)
          };
        } else if (value.type === 'object') {
          var type = value.$id === SCHEMA_REF_ID ? 'reference' : 'object';
          acc[prop] = {
            required: required,
            type: type,
            name: addSchema(records, value, opts)
          };
        } else {
          acc[prop] = _extends({}, value, {
            required: required
          });
        }

        return acc;
      }, {});
    }
  }

  return name;
} // Recursively extract references to other schemas from a JSON schema arrays and objects


function extractSchemaReferences(schema) {
  if (schema.type === 'array') {
    return extractSchemaReferences(schema.items);
  }

  if (schema.type === 'object' && schema.properties != null) {
    var props = schema.properties;

    if (schema.$id === SCHEMA_REF_ID) {
      if (props.schema == null) {
        return [];
      }

      if (Array.isArray(props.schema["enum"])) {
        return props.schema["enum"];
      }

      if (typeof props.schema["const"] === 'string') {
        return [props.schema["const"]];
      }
    }

    return Object.values(props).flatMap(extractSchemaReferences);
  }

  return [];
}

var DocSet = /*#__PURE__*/function () {
  function DocSet(ceramic) {
    this._docs = {};
    this._definitions = {};
    this._schemas = {};
    this._schemaAliases = {};
    this._tiles = {};

    if (ceramic.did == null) {
      throw new Error('Ceramic instance must be authenticated');
    }

    this._ceramic = ceramic;
  }

  var _proto = DocSet.prototype;

  _proto.loadCreated = /*#__PURE__*/function () {
    var _loadCreated = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(created) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = this;
              _context.next = 3;
              return created;

            case 3:
              _context.t1 = _context.sent.id;
              _context.next = 6;
              return _context.t0.loadDoc.call(_context.t0, _context.t1);

            case 6:
              return _context.abrupt("return", _context.sent);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function loadCreated(_x) {
      return _loadCreated.apply(this, arguments);
    }

    return loadCreated;
  }();

  _proto.loadDoc = /*#__PURE__*/function () {
    var _loadDoc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(streamID) {
      var id;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              id = docIDToString(streamID);

              if (this._docs[id] == null) {
                this._docs[id] = this._ceramic.loadStream(id);
              }

              _context2.next = 4;
              return this._docs[id];

            case 4:
              return _context2.abrupt("return", _context2.sent);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function loadDoc(_x2) {
      return _loadDoc.apply(this, arguments);
    }

    return loadDoc;
  }();

  _proto.hasSchema = function hasSchema(alias) {
    return this._schemas[alias] != null;
  };

  _proto.getSchema = function getSchema(alias) {
    var _this$_schemas$alias;

    return (_this$_schemas$alias = this._schemas[alias]) != null ? _this$_schemas$alias : null;
  };

  _proto.deleteSchema = function deleteSchema(alias) {
    if (this.hasSchema(alias)) {
      delete this._schemas[alias];
      return true;
    }

    return false;
  };

  _proto.createSchema = function createSchema(name, schema, deps) {
    var _this = this;

    if (deps === void 0) {
      deps = [];
    }

    if (this.hasSchema(name)) {
      throw new Error("Schema " + name + " already exists");
    }

    this._schemas[name] = Promise.all(deps).then(function (dependencies) {
      return publishSchema(_this._ceramic, {
        name: name,
        content: schema
      }).then(function (doc) {
        _this._schemaAliases[doc.commitId.toUrl()] = name;
        return {
          id: doc.commitId,
          dependencies: dependencies
        };
      }, function (reason) {
        delete _this._schemas[name];
        throw reason;
      });
    });
    return this._schemas[name];
  };

  _proto.addSchema = /*#__PURE__*/function () {
    var _addSchema = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(schema, alias) {
      var _this2 = this;

      var name, schemaRefs, deps, created;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              name = alias != null ? alias : schema.title;

              if (!(name == null)) {
                _context4.next = 3;
                break;
              }

              throw new Error('Schema must have a title property or an alias must be provided');

            case 3:
              schemaRefs = new Set(extractSchemaReferences(schema));
              deps = Array.from(schemaRefs).map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(id) {
                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this2.useExistingSchema(id);

                        case 2:
                          return _context3.abrupt("return", _context3.sent);

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                return function (_x5) {
                  return _ref2.apply(this, arguments);
                };
              }());
              _context4.next = 7;
              return this.createSchema(name, schema, deps);

            case 7:
              created = _context4.sent;
              return _context4.abrupt("return", created.id);

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function addSchema(_x3, _x4) {
      return _addSchema.apply(this, arguments);
    }

    return addSchema;
  }();

  _proto.useExistingSchema = /*#__PURE__*/function () {
    var _useExistingSchema = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(id, alias) {
      var _doc$content,
          _this3 = this;

      var existingAlias, existing, doc, content, name, schemaRefs;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              existingAlias = this._schemaAliases[docIDToString(id)];

              if (!(existingAlias != null)) {
                _context6.next = 8;
                break;
              }

              existing = this._schemas[existingAlias];

              if (!(existing == null)) {
                _context6.next = 5;
                break;
              }

              throw new Error("Alias " + existingAlias + " exists for this schema but no schema is attached");

            case 5:
              _context6.next = 7;
              return existing;

            case 7:
              return _context6.abrupt("return", _context6.sent.id);

            case 8:
              _context6.next = 10;
              return this.loadDoc(id);

            case 10:
              doc = _context6.sent;
              content = (_doc$content = doc.content) != null ? _doc$content : {};
              name = alias != null ? alias : content.title;

              if (!(name == null)) {
                _context6.next = 15;
                break;
              }

              throw new Error('Schema must have a title property or an alias must be provided');

            case 15:
              schemaRefs = new Set(extractSchemaReferences(content));
              this._schemas[name] = Promise.all(Array.from(schemaRefs).map( /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(id) {
                  return runtime_1.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return _this3.useExistingSchema(id);

                        case 2:
                          return _context5.abrupt("return", _context5.sent);

                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                }));

                return function (_x8) {
                  return _ref3.apply(this, arguments);
                };
              }())).then(function (dependencies) {
                _this3._schemaAliases[doc.commitId.toUrl()] = name;
                return {
                  id: doc.commitId,
                  dependencies: dependencies
                };
              }, function (reason) {
                delete _this3._schemas[name];
                throw reason;
              });
              return _context6.abrupt("return", doc.commitId);

            case 18:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function useExistingSchema(_x6, _x7) {
      return _useExistingSchema.apply(this, arguments);
    }

    return useExistingSchema;
  }();

  _proto.hasDefinition = function hasDefinition(alias) {
    return this._definitions[alias] != null;
  };

  _proto.getDefinition = function getDefinition(alias) {
    var _this$_definitions$al;

    return (_this$_definitions$al = this._definitions[alias]) != null ? _this$_definitions$al : null;
  };

  _proto.deleteDefinition = function deleteDefinition(alias) {
    if (this.hasDefinition(alias)) {
      delete this._definitions[alias];
      return true;
    }

    return false;
  };

  _proto.createDefinition = function createDefinition$1(alias, definition, deps) {
    var _this4 = this;

    if (deps === void 0) {
      deps = [];
    }

    if (this.hasDefinition(alias)) {
      throw new Error("Definition " + alias + " already exists");
    }

    this._definitions[alias] = Promise.all(deps).then(function (dependencies) {
      return createDefinition(_this4._ceramic, definition).then(function (doc) {
        return {
          id: doc.id,
          dependencies: dependencies
        };
      }, function (reason) {
        delete _this4._definitions[alias];
        throw reason;
      });
    });
    return this._definitions[alias];
  };

  _proto.addDefinition = /*#__PURE__*/function () {
    var _addDefinition = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(definition, alias) {
      var created;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (alias === void 0) {
                alias = definition.name;
              }

              _context7.next = 3;
              return this.createDefinition(alias, definition, [this.useExistingSchema(definition.schema)]);

            case 3:
              created = _context7.sent;
              return _context7.abrupt("return", created.id);

            case 5:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function addDefinition(_x9, _x10) {
      return _addDefinition.apply(this, arguments);
    }

    return addDefinition;
  }();

  _proto.hasTile = function hasTile(alias) {
    return this._tiles[alias] != null;
  };

  _proto.getTile = function getTile(alias) {
    var _this$_tiles$alias;

    return (_this$_tiles$alias = this._tiles[alias]) != null ? _this$_tiles$alias : null;
  };

  _proto.deleteTile = function deleteTile(alias) {
    if (this.hasTile(alias)) {
      delete this._tiles[alias];
      return true;
    }

    return false;
  };

  _proto.createTile = function createTile$1(alias, contents, meta, deps) {
    var _this5 = this;

    if (deps === void 0) {
      deps = [];
    }

    if (this.hasTile(alias)) {
      throw new Error("Tile " + alias + " already exists");
    }

    this._tiles[alias] = Promise.all(deps).then(function (dependencies) {
      return createTile(_this5._ceramic, contents, meta).then(function (doc) {
        return {
          id: doc.id,
          dependencies: dependencies
        };
      }, function (reason) {
        delete _this5._tiles[alias];
        throw reason;
      });
    });
    return this._tiles[alias];
  };

  _proto.addTile = /*#__PURE__*/function () {
    var _addTile = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(alias, contents, meta) {
      var created;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!(meta.schema == null)) {
                _context8.next = 2;
                break;
              }

              throw new Error('Missing schema to add tile');

            case 2:
              _context8.next = 4;
              return this.createTile(alias, contents, meta, [this.useExistingSchema(meta.schema)]);

            case 4:
              created = _context8.sent;
              return _context8.abrupt("return", created.id);

            case 6:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function addTile(_x11, _x12, _x13) {
      return _addTile.apply(this, arguments);
    }

    return addTile;
  }() // Export to maps of aliases to published doc IDs/URLs
  ;

  _proto.toPublished =
  /*#__PURE__*/
  function () {
    var _toPublished = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12() {
      var definitions, schemas, tiles, handleDefinitions, handleSchemas, handleTiles;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              definitions = {};
              schemas = {};
              tiles = {};
              handleDefinitions = Object.entries(this._definitions).map( /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(_ref4) {
                  var alias, created, _yield$created, id;

                  return runtime_1.wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          alias = _ref4[0], created = _ref4[1];
                          _context9.next = 3;
                          return created;

                        case 3:
                          _yield$created = _context9.sent;
                          id = _yield$created.id;
                          definitions[alias] = id.toString();

                        case 6:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9);
                }));

                return function (_x14) {
                  return _ref5.apply(this, arguments);
                };
              }());
              handleSchemas = Object.entries(this._schemas).map( /*#__PURE__*/function () {
                var _ref7 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(_ref6) {
                  var alias, created, _yield$created2, id;

                  return runtime_1.wrap(function _callee10$(_context10) {
                    while (1) {
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          alias = _ref6[0], created = _ref6[1];
                          _context10.next = 3;
                          return created;

                        case 3:
                          _yield$created2 = _context10.sent;
                          id = _yield$created2.id;
                          schemas[alias] = id.toUrl();

                        case 6:
                        case "end":
                          return _context10.stop();
                      }
                    }
                  }, _callee10);
                }));

                return function (_x15) {
                  return _ref7.apply(this, arguments);
                };
              }());
              handleTiles = Object.entries(this._tiles).map( /*#__PURE__*/function () {
                var _ref9 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(_ref8) {
                  var alias, created, _yield$created3, id;

                  return runtime_1.wrap(function _callee11$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          alias = _ref8[0], created = _ref8[1];
                          _context11.next = 3;
                          return created;

                        case 3:
                          _yield$created3 = _context11.sent;
                          id = _yield$created3.id;
                          tiles[alias] = id.toString();

                        case 6:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  }, _callee11);
                }));

                return function (_x16) {
                  return _ref9.apply(this, arguments);
                };
              }());
              _context12.next = 8;
              return Promise.all([].concat(handleDefinitions, handleSchemas, handleTiles));

            case 8:
              return _context12.abrupt("return", {
                definitions: definitions,
                schemas: schemas,
                tiles: tiles
              });

            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function toPublished() {
      return _toPublished.apply(this, arguments);
    }

    return toPublished;
  }() // Export to maps of aliases to signed commits, would allow to publish a docset on a Ceramic node
  ;

  _proto.toSigned =
  /*#__PURE__*/
  function () {
    var _toSigned = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16() {
      var _this6 = this;

      var deps, docs, definitions, schemas, addDoc, handleDefinitions, handleSchemas, handleTiles;
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              deps = new Set();
              docs = {};
              definitions = [];
              schemas = [];

              addDoc = /*#__PURE__*/function () {
                var _ref10 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(created) {
                  var _yield$created4, id, dependencies, streamid, commits;

                  return runtime_1.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return created;

                        case 2:
                          _yield$created4 = _context13.sent;
                          id = _yield$created4.id;
                          dependencies = _yield$created4.dependencies;
                          dependencies.forEach(function (depid) {
                            deps.add(depid.toString());
                          });
                          streamid = id.baseID;
                          _context13.next = 9;
                          return _this6._ceramic.loadStreamCommits(streamid);

                        case 9:
                          commits = _context13.sent;
                          docs[id.toString()] = commits.map(function (r) {
                            return r.value;
                          });

                        case 11:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }));

                return function addDoc(_x17) {
                  return _ref10.apply(this, arguments);
                };
              }();

              handleDefinitions = Object.entries(this._definitions).map( /*#__PURE__*/function () {
                var _ref12 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(_ref11) {
                  var alias, created;
                  return runtime_1.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          alias = _ref11[0], created = _ref11[1];
                          definitions.push(alias);
                          _context14.next = 4;
                          return addDoc(created);

                        case 4:
                          return _context14.abrupt("return", _context14.sent);

                        case 5:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14);
                }));

                return function (_x18) {
                  return _ref12.apply(this, arguments);
                };
              }());
              handleSchemas = Object.entries(this._schemas).map( /*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(_ref13) {
                  var alias, created;
                  return runtime_1.wrap(function _callee15$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          alias = _ref13[0], created = _ref13[1];
                          schemas.push(alias);
                          _context15.next = 4;
                          return addDoc(created);

                        case 4:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  }, _callee15);
                }));

                return function (_x19) {
                  return _ref14.apply(this, arguments);
                };
              }());
              handleTiles = Object.values(this._tiles).map(addDoc);
              _context16.next = 10;
              return Promise.all([].concat(handleDefinitions, handleSchemas, handleTiles));

            case 10:
              deps.forEach(function (id) {
                if (docs[id] == null) {
                  throw new Error("Missing dependency: " + id);
                }
              });
              return _context16.abrupt("return", {
                docs: docs,
                definitions: definitions,
                schemas: schemas
              });

            case 12:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function toSigned() {
      return _toSigned.apply(this, arguments);
    }

    return toSigned;
  }() // Export signed commits to JSON
  ;

  _proto.toSignedJSON =
  /*#__PURE__*/
  function () {
    var _toSignedJSON = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17() {
      var _yield$this$toSigned, docs, signed;

      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return this.toSigned();

            case 2:
              _yield$this$toSigned = _context17.sent;
              docs = _yield$this$toSigned.docs;
              signed = _objectWithoutPropertiesLoose(_yield$this$toSigned, _excluded);
              return _context17.abrupt("return", _extends({}, signed, {
                docs: encodeSignedMap(docs)
              }));

            case 6:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function toSignedJSON() {
      return _toSignedJSON.apply(this, arguments);
    }

    return toSignedJSON;
  }() // Export to GraphQL docset records for conversion to GraphQL schema
  ;

  _proto.toGraphQLDocSetRecords =
  /*#__PURE__*/
  function () {
    var _toGraphQLDocSetRecords = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21() {
      var _this7 = this;

      var records, handleSchemas, handleDefinitions, handleTiles;
      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              // TODO: throw error on using reserved names:
              // - "node" and "index" roots
              // - "id" field in object if node
              records = {
                index: {},
                lists: {},
                nodes: {},
                objects: {},
                references: {},
                roots: {}
              };
              handleSchemas = this.schemas.map( /*#__PURE__*/function () {
                var _ref15 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(name) {
                  var created, doc, schema;
                  return runtime_1.wrap(function _callee18$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          created = _this7.getSchema(name);

                          if (!(created != null)) {
                            _context18.next = 9;
                            break;
                          }

                          _context18.next = 4;
                          return _this7.loadCreated(created);

                        case 4:
                          doc = _context18.sent;
                          schema = doc.content;

                          if (!(schema == null)) {
                            _context18.next = 8;
                            break;
                          }

                          throw new Error("Could not load schema " + name);

                        case 8:
                          records.nodes[doc.commitId.toUrl()] = addSchema(records, schema, {
                            prefix: ''
                          });

                        case 9:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  }, _callee18);
                }));

                return function (_x20) {
                  return _ref15.apply(this, arguments);
                };
              }());
              handleDefinitions = this.definitions.map( /*#__PURE__*/function () {
                var _ref16 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(name) {
                  var created, doc, _definition;

                  return runtime_1.wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          created = _this7.getDefinition(name);

                          if (!(created != null)) {
                            _context19.next = 9;
                            break;
                          }

                          _context19.next = 4;
                          return _this7.loadCreated(created);

                        case 4:
                          doc = _context19.sent;
                          _definition = doc.content;

                          if (!(_definition == null)) {
                            _context19.next = 8;
                            break;
                          }

                          throw new Error("Could not load definition " + name);

                        case 8:
                          records.index[name] = {
                            id: doc.id.toString(),
                            schema: _definition.schema
                          };

                        case 9:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19);
                }));

                return function (_x21) {
                  return _ref16.apply(this, arguments);
                };
              }());
              handleTiles = this.tiles.map( /*#__PURE__*/function () {
                var _ref17 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(name) {
                  var created, doc, schema;
                  return runtime_1.wrap(function _callee20$(_context20) {
                    while (1) {
                      switch (_context20.prev = _context20.next) {
                        case 0:
                          created = _this7.getTile(name);

                          if (!(created != null)) {
                            _context20.next = 9;
                            break;
                          }

                          _context20.next = 4;
                          return _this7.loadCreated(created);

                        case 4:
                          doc = _context20.sent;
                          schema = doc.metadata.schema;

                          if (!(schema == null)) {
                            _context20.next = 8;
                            break;
                          }

                          throw new Error("Missing schema for tile " + name);

                        case 8:
                          records.roots[name] = {
                            id: doc.id.toString(),
                            schema: schema
                          };

                        case 9:
                        case "end":
                          return _context20.stop();
                      }
                    }
                  }, _callee20);
                }));

                return function (_x22) {
                  return _ref17.apply(this, arguments);
                };
              }());
              _context21.next = 6;
              return Promise.all([].concat(handleSchemas, handleDefinitions, handleTiles));

            case 6:
              return _context21.abrupt("return", records);

            case 7:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this);
    }));

    function toGraphQLDocSetRecords() {
      return _toGraphQLDocSetRecords.apply(this, arguments);
    }

    return toGraphQLDocSetRecords;
  }();

  _createClass(DocSet, [{
    key: "definitions",
    get: function get() {
      return Object.keys(this._definitions);
    }
  }, {
    key: "schemas",
    get: function get() {
      return Object.keys(this._schemas);
    }
  }, {
    key: "tiles",
    get: function get() {
      return Object.keys(this._tiles);
    }
  }]);

  return DocSet;
}(); // Publish a signed docset to the given Ceramic node

function publishSignedDocSet(_x23, _x24) {
  return _publishSignedDocSet.apply(this, arguments);
} // Publish a JSON-encoded signed docset to the given Ceramic node

function _publishSignedDocSet() {
  _publishSignedDocSet = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(ceramic, docSet) {
    var schemas, others;
    return runtime_1.wrap(function _callee22$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            schemas = [];
            others = [];
            Object.entries(docSet.docs).forEach(function (_ref19) {
              var id = _ref19[0],
                  commits = _ref19[1];
              var publish = publishCommits(ceramic, commits);

              if (docSet.schemas.includes(id)) {
                schemas.push(publish);
              } else {
                others.push(publish);
              }
            });
            _context22.next = 5;
            return Promise.all(schemas);

          case 5:
            _context22.next = 7;
            return Promise.all(others);

          case 7:
          case "end":
            return _context22.stop();
        }
      }
    }, _callee22);
  }));
  return _publishSignedDocSet.apply(this, arguments);
}

function publishEncodedSignedDocSet(_x25, _x26) {
  return _publishEncodedSignedDocSet.apply(this, arguments);
}

function _publishEncodedSignedDocSet() {
  _publishEncodedSignedDocSet = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee23(ceramic, _ref18) {
    var docs, docSet;
    return runtime_1.wrap(function _callee23$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            docs = _ref18.docs, docSet = _objectWithoutPropertiesLoose(_ref18, _excluded2);
            _context23.next = 3;
            return publishSignedDocSet(ceramic, _extends({}, docSet, {
              docs: decodeSignedMap(docs)
            }));

          case 3:
            return _context23.abrupt("return", _context23.sent);

          case 4:
          case "end":
            return _context23.stop();
        }
      }
    }, _callee23);
  }));
  return _publishEncodedSignedDocSet.apply(this, arguments);
}

export { DocSet, SCHEMA_REF_ID, applyMap, createDefinition, createIDXDefinitions, createIDXSignedDefinitions, createTile, decodeDagJWS, decodeDagJWSResult, decodeSignedMap, docIDToString, encodeDagJWS, encodeDagJWSResult, encodeSignedMap, isSecureSchema, isValidDefinition, promiseMap, publishCommits, publishDoc, publishEncodedSignedDocSet, publishIDXConfig, publishIDXSignedDefinitions, publishIDXSignedSchemas, publishSchema, publishSignedDocSet, publishSignedMap, schemas, signIDXDefinitions, signIDXSchemas, signTile, signedDefinitions, signedSchemas, updateDefinition, validateDefinition, validateSchemaSecure };
//# sourceMappingURL=idx-tools.esm.js.map
