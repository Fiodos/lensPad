'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var StackError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(StackError, _Error);

  function StackError(code, message, wrapError) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.metadata = {};
    _this.name = 'StackError';
    Object.setPrototypeOf(_assertThisInitialized(_this), StackError.prototype);

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), StackError);
    }

    _this.code = code;
    _this.errorStack = wrapError ? StackError.from(wrapError).toErrorStack() : [];
    return _this;
  }

  StackError.from = function from(error, code) {
    if (code === void 0) {
      code = 'SE0';
    }

    if (error instanceof StackError) {
      return error;
    }

    var se = new StackError(code, error.message);
    se.stack = error.stack;
    return se;
  };

  StackError.fromJSON = function fromJSON(json) {
    var _json$stack, _json$metadata, _json$name;

    var error = new StackError(json.code, json.message);
    error.errorStack = ((_json$stack = json.stack) != null ? _json$stack : []).reduceRight(function (stack, e) {
      var err = StackError.fromJSON(e);
      err.errorStack = stack;
      return [err].concat(stack);
    }, []);
    error.metadata = (_json$metadata = json.metadata) != null ? _json$metadata : {};
    error.name = (_json$name = json.name) != null ? _json$name : 'StackError';
    return error;
  };

  var _proto = StackError.prototype;

  _proto.toErrorStack = function toErrorStack() {
    return [this].concat(this.errorStack);
  };

  _proto.toJSON = function toJSON(withStack) {
    if (withStack === void 0) {
      withStack = true;
    }

    return {
      code: this.code,
      message: this.message,
      metadata: this.metadata,
      name: this.name,
      stack: withStack ? this.errorStack.map(function (e) {
        return e.toJSON(false);
      }) : []
    };
  };

  _proto.toString = function toString() {
    return "[" + this.code + "] " + this.message;
  };

  return StackError;
}( /*#__PURE__*/_wrapNativeSuper(Error)); // eslint-disable-next-line @typescript-eslint/explicit-function-return-type

function createNamespaceError(namespace, metadata) {
  if (metadata === void 0) {
    metadata = {};
  }

  return /*#__PURE__*/function (_StackError) {
    _inheritsLoose(NamespaceError, _StackError);

    function NamespaceError(code, message, wrapError) {
      var _this2;

      _this2 = _StackError.call(this, "" + namespace + code, message, wrapError) || this;
      Object.setPrototypeOf(_assertThisInitialized(_this2), NamespaceError.prototype);

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this2), NamespaceError);
      }

      _this2.metadata = metadata;
      return _this2;
    }

    return NamespaceError;
  }(StackError);
}
function assert(condition, message) {
  if (message === void 0) {
    message = 'Assertion failed';
  }

  if (!condition) {
    throw new Error(message);
  }
}
function assertAs(condition, ErrorClass) {
  if (!condition) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    // @ts-ignore args
    throw _construct(ErrorClass, args);
  }
}

exports.StackError = StackError;
exports.assert = assert;
exports.assertAs = assertAs;
exports.createNamespaceError = createNamespaceError;
//# sourceMappingURL=errors-utils.cjs.development.js.map
