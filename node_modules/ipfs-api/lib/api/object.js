'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var DAGNode = require('ipfs-merkle-dag').DAGNode;
var DAGLink = require('ipfs-merkle-dag').DAGLink;
var promisify = require('promisify-es6');
var bs58 = require('bs58');
var bl = require('bl');

module.exports = function (send) {
  var api = {
    get: promisify(function (multihash, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      try {
        multihash = cleanMultihash(multihash, options);
      } catch (err) {
        return callback(err);
      }

      send('object/get', multihash, null, null, function (err, result) {
        if (err) {
          return callback(err);
        }

        var node = new DAGNode(result.Data, result.Links.map(function (l) {
          return new DAGLink(l.Name, l.Size, new Buffer(bs58.decode(l.Hash)));
        }));

        callback(null, node);
      });
    }),
    put: promisify(function (obj, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      var tmpObj = {
        Data: null,
        Links: []
      };

      if (Buffer.isBuffer(obj)) {
        if (!options.enc) {
          tmpObj = { Data: obj.toString(), Links: [] };
        }
      } else if (obj.multihash) {
        tmpObj = {
          Data: obj.data.toString(),
          Links: obj.links.map(function (l) {
            return l.toJSON();
          })
        };
      } else if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
        tmpObj.Data = obj.Data.toString();
      } else {
        return callback(new Error('obj not recognized'));
      }

      var buf = void 0;
      if (Buffer.isBuffer(obj) && options.enc) {
        buf = obj;
      } else {
        buf = new Buffer(JSON.stringify(tmpObj));
      }
      var enc = options.enc || 'json';

      send('object/put', null, { inputenc: enc }, buf, function (err, result) {
        if (err) {
          return callback(err);
        }

        if (Buffer.isBuffer(obj)) {
          if (!options.enc) {
            obj = { Data: obj, Links: [] };
          } else if (options.enc === 'json') {
            obj = JSON.parse(obj.toString());
          }
        }
        var node = void 0;
        if (obj.multihash) {
          node = obj;
        } else if (options.enc === 'protobuf') {
          node = new DAGNode();
          node.unMarshal(obj);
        } else {
          node = new DAGNode(obj.Data, obj.Links);
        }

        if (node.toJSON().Hash !== result.Hash) {
          return callback(new Error('Stored object was different from constructed object'));
        }

        callback(null, node);
      });
    }),
    data: promisify(function (multihash, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      try {
        multihash = cleanMultihash(multihash, options);
      } catch (err) {
        return callback(err);
      }

      send('object/data', multihash, null, null, function (err, result) {
        if (err) {
          return callback(err);
        }

        if (typeof result.pipe === 'function') {
          result.pipe(bl(callback));
        } else {
          callback(null, result);
        }
      });
    }),
    links: promisify(function (multihash, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      try {
        multihash = cleanMultihash(multihash, options);
      } catch (err) {
        return callback(err);
      }

      send('object/links', multihash, null, null, function (err, result) {
        if (err) {
          return callback(err);
        }

        var links = [];

        if (result.Links) {
          links = result.Links.map(function (l) {
            return new DAGLink(l.Name, l.Size, new Buffer(bs58.decode(l.Hash)));
          });
        }
        callback(null, links);
      });
    }),
    stat: promisify(function (multihash, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }

      try {
        multihash = cleanMultihash(multihash, options);
      } catch (err) {
        return callback(err);
      }

      send('object/stat', multihash, null, null, callback);
    }),
    new: promisify(function (callback) {
      send('object/new', null, null, null, function (err, result) {
        if (err) {
          return callback(err);
        }
        var node = new DAGNode();

        if (node.toJSON().Hash !== result.Hash) {
          return callback(new Error('Stored object was different from constructed object'));
        }

        callback(null, node);
      });
    }),
    patch: {
      addLink: promisify(function (multihash, dLink, options, callback) {
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        if (!options) {
          options = {};
        }

        try {
          multihash = cleanMultihash(multihash, options);
        } catch (err) {
          return callback(err);
        }

        send('object/patch/add-link', [multihash, dLink.name, bs58.encode(dLink.hash).toString()], null, null, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      }),
      rmLink: promisify(function (multihash, dLink, options, callback) {
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        if (!options) {
          options = {};
        }

        try {
          multihash = cleanMultihash(multihash, options);
        } catch (err) {
          return callback(err);
        }

        send('object/patch/rm-link', [multihash, dLink.name], null, null, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      }),
      setData: promisify(function (multihash, data, options, callback) {
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        if (!options) {
          options = {};
        }

        try {
          multihash = cleanMultihash(multihash, options);
        } catch (err) {
          return callback(err);
        }

        send('object/patch/set-data', [multihash], null, data, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      }),
      appendData: promisify(function (multihash, data, options, callback) {
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        if (!options) {
          options = {};
        }

        try {
          multihash = cleanMultihash(multihash, options);
        } catch (err) {
          return callback(err);
        }

        send('object/patch/append-data', [multihash], null, data, function (err, result) {
          if (err) {
            return callback(err);
          }
          api.get(result.Hash, { enc: 'base58' }, callback);
        });
      })
    }
  };
  return api;
};

function cleanMultihash(multihash, options) {
  if (Buffer.isBuffer(multihash)) {
    if (options.enc) {
      switch (options.enc) {
        case 'base58':
          {
            multihash = multihash.toString();
            break;
          }
        default:
          throw new Error('invalid multihash');
      }
    } else {
      multihash = bs58.encode(multihash).toString();
    }
  } else if (typeof multihash === 'string') {
    if (options.enc) {
      // For the future, when we support more than one enc
      // switch (options.enc) {
      //   case 'base58':  // It is good
      // }
    } else {
      throw new Error('not valid multihash');
    }
  } else if (!multihash) {
    throw new Error('missing valid multihash');
  }

  return multihash;
}