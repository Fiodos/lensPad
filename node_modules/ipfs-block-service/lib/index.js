'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var async = require('async');

// BlockService is a hybrid block datastore. It stores data in a local
// datastore and may retrieve data from a remote Exchange.
// It uses an internal `datastore.Datastore` instance to store values.
module.exports = function () {
  function BlockService(ipfsRepo) {
    _classCallCheck(this, BlockService);

    this._repo = ipfsRepo;
    this._bitswap = null;
  }

  _createClass(BlockService, [{
    key: 'goOnline',
    value: function goOnline(bitswap) {
      this._bitswap = bitswap;
    }
  }, {
    key: 'goOffline',
    value: function goOffline() {
      this._bitswap = null;
    }
  }, {
    key: 'isOnline',
    value: function isOnline() {
      return this._bitswap != null;
    }
  }, {
    key: 'addBlock',
    value: function addBlock(block, extension, callback) {
      if (this.isOnline()) {
        if (typeof extension === 'function') {
          callback = extension;
          extension = undefined;
        }

        this._bitswap.hasBlock(block, callback);
      } else {
        this._repo.datastore.put(block, extension, callback);
      }
    }
  }, {
    key: 'addBlocks',
    value: function addBlocks(blocks, callback) {
      var _this = this;

      if (!Array.isArray(blocks)) {
        return callback(new Error('expects an array of Blocks'));
      }

      async.eachLimit(blocks, 100, function (block, next) {
        _this.addBlock(block, next);
      }, callback);
    }
  }, {
    key: 'getBlock',
    value: function getBlock(key, extension, callback) {
      if (this.isOnline()) {
        if (typeof extension === 'function') {
          callback = extension;
          extension = undefined;
        }

        this._bitswap.getBlock(key, callback);
      } else {
        this._repo.datastore.get(key, extension, callback);
      }
    }
  }, {
    key: 'getBlocks',
    value: function getBlocks(multihashes, extension, callback) {
      var _this2 = this;

      if (typeof extension === 'function') {
        callback = extension;
        extension = undefined;
      }

      if (!Array.isArray(multihashes)) {
        return callback(new Error('Invalid batch of multihashes'));
      }

      var results = {};

      async.eachLimit(multihashes, 100, function (multihash, next) {
        _this2.getBlock(multihash, extension, function (err, block) {
          results[multihash] = {
            err: err,
            block: block
          };
          next();
        });
      }, function (err) {
        callback(err, results);
      });
    }
  }, {
    key: 'deleteBlock',
    value: function deleteBlock(key, extension, callback) {
      this._repo.datastore.delete(key, extension, callback);
    }
  }, {
    key: 'deleteBlocks',
    value: function deleteBlocks(multihashes, extension, callback) {
      var _this3 = this;

      if (typeof extension === 'function') {
        callback = extension;
        extension = undefined;
      }

      if (!Array.isArray(multihashes)) {
        return callback(new Error('Invalid batch of multihashes'));
      }

      async.eachLimit(multihashes, 100, function (multihash, next) {
        _this3.deleteBlock(multihash, extension, next);
      }, function (err) {
        callback(err);
      });
    }
  }]);

  return BlockService;
}();