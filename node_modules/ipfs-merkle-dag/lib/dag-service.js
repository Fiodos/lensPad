'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Block = require('ipfs-block');
var isIPFS = require('is-ipfs');
var base58 = require('bs58');

var DAGNode = require('./dag-node');

module.exports = function () {
  function DAGService(blockService) {
    _classCallCheck(this, DAGService);

    if (!blockService) {
      throw new Error('DAGService requires a BlockService instance');
    }

    this.bs = blockService;
  }

  // add a DAGNode to the service, storing it on the block service


  _createClass(DAGService, [{
    key: 'add',
    value: function add(node, callback) {
      this.bs.addBlock(new Block(node.encoded()), callback);
    }

    // DEPRECATED - https://github.com/ipfs/go-ipfs/issues/2262
    // this.addRecursive

    // get retrieves a DAGNode, using the Block Service

  }, {
    key: 'get',
    value: function get(multihash, callback) {
      var isMhash = isIPFS.multihash(multihash);
      var isPath = isIPFS.path(multihash);

      if (!isMhash && !isPath) {
        return callback(new Error('Invalid Key'));
      }

      if (isMhash) {
        this.getWith(multihash, callback);
      }

      if (isPath) {
        var ipfsKey = multihash.replace('/ipfs/', '');
        this.getWith(ipfsKey, callback);
      }
    }
  }, {
    key: 'getWith',
    value: function getWith(key, callback) {
      var formatted = typeof key === 'string' ? new Buffer(base58.decode(key)) : key;
      this.bs.getBlock(formatted, function (err, block) {
        if (err) {
          return callback(err);
        }

        var node = new DAGNode();
        node.unMarshal(block.data);
        return callback(null, node);
      });
    }

    // getRecursive fetches a node and all of the nodes on its links recursively
    // TODO add depth param

  }, {
    key: 'getRecursive',
    value: function getRecursive(multihash, callback, linkStack, nodeStack) {
      var _this = this;

      this.get(multihash, function (err, node) {
        if (err && nodeStack.length > 0) {
          return callback(new Error('Could not complete the recursive get'), nodeStack);
        }
        if (err) {
          return callback(err);
        }

        if (!linkStack) {
          linkStack = [];
        }
        if (!nodeStack) {
          nodeStack = [];
        }

        nodeStack.push(node);

        var keys = node.links.map(function (link) {
          return link.hash;
        });

        linkStack = linkStack.concat(keys);

        var next = linkStack.pop();

        if (next) {
          _this.getRecursive(next, callback, linkStack, nodeStack);
        } else {
          var compare = function compare(hash) {
            return function (node) {
              node.multihash().equals(hash);
            };
          };

          var link = void 0;
          for (var k = 0; k < nodeStack.length; k++) {
            var current = nodeStack[k];
            for (var j = 0; j < current.links.length; j++) {
              link = current.links[j];
              var index = nodeStack.findIndex(compare(link.hash));
              if (index !== -1) {
                link.node = nodeStack[index];
              }
            }
          }
          return callback(null, nodeStack);
        }
      });
    }

    // remove deletes a node with given multihash from the blockService

  }, {
    key: 'remove',
    value: function remove(multihash, cb) {
      if (!multihash) {
        return cb(new Error('Invalid multihash'));
      }

      this.bs.deleteBlock(multihash, cb);
    }

    // DEPRECATED - https://github.com/ipfs/go-ipfs/issues/2262
    // this.removeRecursive = (key, callback) => { }

  }]);

  return DAGService;
}();