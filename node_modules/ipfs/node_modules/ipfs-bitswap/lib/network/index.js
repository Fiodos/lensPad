'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var bl = require('bl');
var async = require('async');
var debug = require('debug');
var lps = require('length-prefixed-stream');

var Message = require('../message');
var cs = require('../constants');
var log = debug('bitswap:network');

// Go does not yet support /1.0.0
// const PROTOCOL_IDENTIFIER = '/ipfs/bitswap/1.0.0'
var PROTOCOL_IDENTIFIER = '/ipfs/bitswap';

module.exports = function () {
  function Network(libp2p, peerBook, bitswap) {
    _classCallCheck(this, Network);

    this.libp2p = libp2p;
    this.peerBook = peerBook;
    this.bitswap = bitswap;

    // increase event listener max
    this.libp2p.swarm.setMaxListeners(cs.maxListeners);
  }

  _createClass(Network, [{
    key: 'start',
    value: function start() {
      var _this = this;

      // bind event listeners
      this._onConnection = this._onConnection.bind(this);
      this._onPeerMux = this._onPeerMux.bind(this);
      this._onPeerMuxClosed = this._onPeerMuxClosed.bind(this);

      this.libp2p.handle(PROTOCOL_IDENTIFIER, this._onConnection);

      this.libp2p.swarm.on('peer-mux-established', this._onPeerMux);

      this.libp2p.swarm.on('peer-mux-closed', this._onPeerMuxClosed);

      // All existing connections are like new ones for us
      var pKeys = Object.keys(this.peerBook.getAll());
      pKeys.forEach(function (k) {
        _this._onPeerMux(_this.peerBook.getByB58String(k));
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.libp2p.unhandle(PROTOCOL_IDENTIFIER);
      this.libp2p.swarm.removeListener('peer-mux-established', this._onPeerMux);

      this.libp2p.swarm.removeListener('peer-mux-closed', this._onPeerMuxClosed);
    }
  }, {
    key: '_onConnection',
    value: function _onConnection(conn) {
      var _this2 = this;

      var decode = lps.decode();
      conn.pipe(decode).pipe(bl(function (err, data) {
        conn.end();
        if (err) {
          return _this2.bitswap._receiveError(err);
        }
        var msg = void 0;
        try {
          msg = Message.fromProto(data);
        } catch (err) {
          return _this2.bitswap._receiveError(err);
        }
        conn.getPeerInfo(function (err, peerInfo) {
          if (err) {
            return _this2.bitswap._receiveError(err);
          }
          _this2.bitswap._receiveMessage(peerInfo.id, msg);
        });
      }));

      conn.on('error', function (err) {
        _this2.bitswap._receiveError(err);
        conn.end();
      });
    }
  }, {
    key: '_onPeerMux',
    value: function _onPeerMux(peerInfo) {
      this.bitswap._onPeerConnected(peerInfo.id);
    }
  }, {
    key: '_onPeerMuxClosed',
    value: function _onPeerMuxClosed(peerInfo) {
      this.bitswap._onPeerDisconnected(peerInfo.id);
    }

    // Connect to the given peer

  }, {
    key: 'connectTo',
    value: function connectTo(peerId, cb) {
      log('connecting to %s', peerId.toB58String());
      var done = function done(err) {
        return async.setImmediate(function () {
          return cb(err);
        });
      };
      // NOTE: For now, all this does is ensure that we are
      // connected. Once we have Peer Routing, we will be able
      // to find the Peer
      if (this.libp2p.swarm.muxedConns[peerId.toB58String()]) {
        done();
      } else {
        done(new Error('Could not connect to peer with peerId:', peerId.toB58String()));
      }
    }

    // Send the given msg (instance of Message) to the given peer

  }, {
    key: 'sendMessage',
    value: function sendMessage(peerId, msg, cb) {
      log('sendMessage to %s', peerId.toB58String());
      log('msg %s', msg.full, msg.wantlist, msg.blocks);
      var done = function done(err) {
        return async.setImmediate(function () {
          return cb(err);
        });
      };
      var peerInfo = void 0;
      try {
        peerInfo = this.peerBook.getByMultihash(peerId.toBytes());
      } catch (err) {
        return done(err);
      }

      this.libp2p.dialByPeerInfo(peerInfo, PROTOCOL_IDENTIFIER, function (err, conn) {
        if (err) {
          return done(err);
        }

        conn.once('error', function (err) {
          return done(err);
        });
        conn.once('finish', done);

        var encode = lps.encode();
        encode.pipe(conn);
        encode.write(msg.toProto());
        encode.end();
      });
    }
  }]);

  return Network;
}();