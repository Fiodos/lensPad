'use strict';

var Lock = require('lock');
var stream = require('stream');
var bl = require('bl');
var Block = require('ipfs-block');

var PREFIX_LENGTH = 8;

exports = module.exports;

function multihashToPath(multihash, extension) {
  extension = extension || 'data';
  var filename = multihash.toString('hex') + '.' + extension;
  var folder = filename.slice(0, PREFIX_LENGTH);
  var path = folder + '/' + filename;

  return path;
}

exports.setUp = function (basePath, blobStore, locks) {
  var store = blobStore(basePath + '/blocks');
  var lock = new Lock();

  var createReadStream = function createReadStream(multihash, extension) {
    var path = multihashToPath(multihash, extension);
    return store.createReadStream(path);
  };

  var createWriteStream = function createWriteStream(multihash, extension, cb) {
    var path = multihashToPath(multihash, extension);
    var through = stream.PassThrough();

    lock(path, function (release) {
      var ws = store.createWriteStream(path, release(cb));
      through.pipe(ws);
    });

    return through;
  };

  return {
    get: function get(key, extension, cb) {
      if (typeof extension === 'function') {
        cb = extension;
        extension = 'data';
      }

      if (!key) {
        return cb(new Error('Invalid key'));
      }

      createReadStream(key, extension).pipe(bl(function (err, data) {
        if (err) {
          return cb(err);
        }
        if (extension === 'data') {
          extension = 'protobuf';
        }
        cb(null, new Block(data, extension));
      }));
    },

    put: function put(block, cb) {
      if (!block || !block.data) {
        return cb(new Error('Invalid block'));
      }

      var ws = createWriteStream(block.key, block.extension, cb);
      ws.write(block.data);
      ws.end();
    },

    has: function has(key, extension, cb) {
      if (typeof extension === 'function') {
        cb = extension;
        extension = undefined;
      }

      if (!key) {
        return cb(new Error('Invalid key'));
      }

      var path = multihashToPath(key, extension);
      store.exists(path, cb);
    },

    delete: function _delete(key, extension, cb) {
      if (typeof extension === 'function') {
        cb = extension;
        extension = undefined;
      }

      if (!key) {
        return cb(new Error('Invalid key'));
      }

      var path = multihashToPath(key, extension);
      store.remove(path, cb);
    }
  };
};