/*
 * Identify is one of the protocols swarms speaks in order to
 * broadcast and learn about the ip:port pairs a specific peer
 * is available through and to know when a new stream muxer is
 * established, so a conn can be reused
 */

'use strict';

var fs = require('fs');
var path = require('path');
var PeerInfo = require('peer-info');
var PeerId = require('peer-id');
var multiaddr = require('multiaddr');
var bl = require('bl');

var lpstream = require('length-prefixed-stream');
var protobuf = require('protocol-buffers');
var schema = fs.readFileSync(path.join(__dirname, 'identify.proto'));
var idPb = protobuf(schema);

exports = module.exports;
exports.multicodec = '/ipfs/id/1.0.0';

exports.exec = function (conn, callback) {
  var decode = lpstream.decode();

  conn.pipe(decode).pipe(bl(function (err, data) {
    if (err) {
      return callback(err);
    }
    var msg = idPb.Identify.decode(data);
    var observedAddrs = [];
    if (hasObservedAddr(msg)) {
      if (!Array.isArray(msg.observedAddr)) {
        msg.observedAddr = [msg.observedAddr];
      }
      observedAddrs = msg.observedAddr.map(function (oa) {
        return multiaddr(oa);
      });
    }

    var pId = PeerId.createFromPubKey(msg.publicKey);
    var pInfo = new PeerInfo(pId);
    msg.listenAddrs.forEach(function (ma) {
      pInfo.multiaddr.add(multiaddr(ma));
    });

    callback(null, pInfo, observedAddrs);
  }));

  conn.end();
};

exports.handler = function (pInfoSelf) {
  return function (conn) {
    // send what I see from the other + my Info
    var encode = lpstream.encode();

    encode.pipe(conn);

    conn.getObservedAddrs(function (err, observedAddrs) {
      if (err) {
        return;
      }
      observedAddrs = observedAddrs[0];

      var publicKey = new Buffer(0);
      if (pInfoSelf.id.pubKey) {
        publicKey = pInfoSelf.id.pubKey.bytes;
      }

      var msgSend = idPb.Identify.encode({
        protocolVersion: 'ipfs/0.1.0',
        agentVersion: 'na',
        publicKey: publicKey,
        listenAddrs: pInfoSelf.multiaddrs.map(function (ma) {
          return ma.buffer;
        }),
        observedAddr: observedAddrs ? observedAddrs.buffer : new Buffer('')
      });

      encode.write(msgSend);
      encode.end();
    });
  };
};

function hasObservedAddr(msg) {
  return msg.observedAddr && msg.observedAddr.length > 0;
}