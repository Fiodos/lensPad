'use strict';

var protocolMuxer = require('./protocol-muxer');
var identify = require('libp2p-identify');
var multistream = require('multistream-select');

module.exports = function connection(swarm) {
  return {
    addUpgrade: function addUpgrade() {},
    addStreamMuxer: function addStreamMuxer(muxer) {
      // for dialing
      swarm.muxers[muxer.multicodec] = muxer;

      // for listening
      swarm.handle(muxer.multicodec, function (conn) {
        var muxedConn = muxer(conn, true);

        muxedConn.on('stream', function (conn) {
          protocolMuxer(swarm.protocols, conn);
        });

        // If identify is enabled
        //   1. overload getPeerInfo
        //   2. call getPeerInfo
        //   3. add this conn to the pool
        if (swarm.identify) {
          // overload peerInfo to use Identify instead
          conn.getPeerInfo = function (cb) {
            var conn = muxedConn.newStream();
            var ms = new multistream.Dialer();
            ms.handle(conn, function (err) {
              if (err) {
                return cb(err);
              }

              ms.select(identify.multicodec, function (err, conn) {
                if (err) {
                  return cb(err);
                }

                identify.exec(conn, function (err, peerInfo, observedAddrs) {
                  if (err) {
                    return cb(err);
                  }

                  observedAddrs.forEach(function (oa) {
                    swarm._peerInfo.multiaddr.addSafe(oa);
                  });

                  cb(null, peerInfo);
                });
              });
            });
          };

          conn.getPeerInfo(function (err, peerInfo) {
            if (err) {
              return console.log('Identify not successful');
            }
            swarm.muxedConns[peerInfo.id.toB58String()] = {
              muxer: muxedConn
            };

            swarm.emit('peer-mux-established', peerInfo);
            muxedConn.on('close', function () {
              delete swarm.muxedConns[peerInfo.id.toB58String()];
              swarm.emit('peer-mux-closed', peerInfo);
            });
          });
        }
      });
    },
    reuse: function reuse() {
      swarm.identify = true;
      swarm.handle(identify.multicodec, identify.handler(swarm._peerInfo));
    }
  };
};