'use strict';

var debug = require('debug');
var log = debug('libp2p:tcp');
var tcp = require('net');
var multiaddr = require('multiaddr');
var Address6 = require('ip-address').Address6;
var mafmt = require('mafmt');
// const parallel = require('run-parallel')
var contains = require('lodash.contains');
var os = require('os');
var Connection = require('interface-connection').Connection;

exports = module.exports = TCP;

var IPFS_CODE = 421;
var CLOSE_TIMEOUT = 2000;

function TCP() {
  if (!(this instanceof TCP)) {
    return new TCP();
  }

  this.dial = function (ma, options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!callback) {
      callback = function noop() {};
    }

    var socket = tcp.connect(ma.toOptions());
    var conn = new Connection(socket);

    socket.on('timeout', function () {
      conn.emit('timeout');
    });

    socket.once('error', function (err) {
      callback(err);
    });

    socket.on('connect', function () {
      callback(null, conn);
      conn.emit('connect');
    });

    conn.getObservedAddrs = function (cb) {
      return cb(null, [ma]);
    };

    return conn;
  };

  this.createListener = function (options, handler) {
    if (typeof options === 'function') {
      handler = options;
      options = {};
    }

    var listener = tcp.createServer(function (socket) {
      var conn = new Connection(socket);

      conn.getObservedAddrs = function (cb) {
        return cb(null, [getMultiaddr(socket)]);
      };
      handler(conn);
    });

    var ipfsId = void 0;
    var listeningMultiaddr = void 0;

    listener._listen = listener.listen;
    listener.listen = function (ma, callback) {
      listeningMultiaddr = ma;
      if (contains(ma.protoNames(), 'ipfs')) {
        ipfsId = ma.stringTuples().filter(function (tuple) {
          if (tuple[0] === IPFS_CODE) {
            return true;
          }
        })[0][1];
        listeningMultiaddr = ma.decapsulate('ipfs');
      }

      listener._listen(listeningMultiaddr.toOptions(), callback);
    };

    listener._close = listener.close;
    listener.close = function (options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (!callback) {
        callback = function noop() {};
      }
      if (!options) {
        options = {};
      }

      var closed = false;
      listener._close(callback);
      listener.once('close', function () {
        closed = true;
      });
      setTimeout(function () {
        if (closed) {
          return;
        }
        log('unable to close graciously, destroying conns');
        Object.keys(listener.__connections).forEach(function (key) {
          log('destroying %s', key);
          listener.__connections[key].destroy();
        });
      }, options.timeout || CLOSE_TIMEOUT);
    };

    // Keep track of open connections to destroy in case of timeout
    listener.__connections = {};
    listener.on('connection', function (socket) {
      var key = socket.remoteAddress + ':' + socket.remotePort;
      listener.__connections[key] = socket;

      socket.on('close', function () {
        delete listener.__connections[key];
      });
    });

    listener.getAddrs = function (callback) {
      var multiaddrs = [];
      var address = listener.address();

      // Because TCP will only return the IPv6 version
      // we need to capture from the passed multiaddr
      if (listeningMultiaddr.toString().indexOf('ip4') !== -1) {
        (function () {
          var m = listeningMultiaddr.decapsulate('tcp');
          m = m.encapsulate('/tcp/' + address.port);
          if (ipfsId) {
            m = m.encapsulate('/ipfs/' + ipfsId);
          }

          if (m.toString().indexOf('0.0.0.0') !== -1) {
            (function () {
              var netInterfaces = os.networkInterfaces();
              Object.keys(netInterfaces).forEach(function (niKey) {
                netInterfaces[niKey].forEach(function (ni) {
                  if (ni.family === 'IPv4') {
                    multiaddrs.push(multiaddr(m.toString().replace('0.0.0.0', ni.address)));
                  }
                });
              });
            })();
          } else {
            multiaddrs.push(m);
          }
        })();
      }

      if (address.family === 'IPv6') {
        var ma = multiaddr('/ip6/' + address.address + '/tcp/' + address.port);
        if (ipfsId) {
          ma = ma.encapsulate('/ipfs/' + ipfsId);
        }

        multiaddrs.push(ma);
      }

      callback(null, multiaddrs);
    };

    return listener;
    /*
      listener.listen(m.toOptions(), () => {
        // Node.js likes to convert addr to IPv6 (when 0.0.0.0 for e.g)
        const address = listener.address()
        if (m.toString().indexOf('ip4')) {
          m = m.decapsulate('tcp')
          m = m.encapsulate('/tcp/' + address.port)
          if (ipfsHashId) {
            m = m.encapsulate('/ipfs/' + ipfsHashId)
          }
          freshMultiaddrs.push(m)
        }
         if (address.family === 'IPv6') {
          let mh = multiaddr('/ip6/' + address.address + '/tcp/' + address.port)
          if (ipfsHashId) {
            mh = mh.encapsulate('/ipfs/' + ipfsHashId)
          }
           freshMultiaddrs.push(mh)
        }
         cb()
      })
      listeners.push(listener)
    */
  };

  this.filter = function (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs];
    }
    return multiaddrs.filter(function (ma) {
      if (contains(ma.protoNames(), 'ipfs')) {
        ma = ma.decapsulate('ipfs');
      }
      return mafmt.TCP.matches(ma);
    });
  };
}

function getMultiaddr(socket) {
  var mh;

  if (socket.remoteFamily === 'IPv6') {
    var addr = new Address6(socket.remoteAddress);
    if (addr.v4) {
      var ip4 = addr.to4().correctForm();
      mh = multiaddr('/ip4/' + ip4 + '/tcp/' + socket.remotePort);
    } else {
      mh = multiaddr('/ip6/' + socket.remoteAddress + '/tcp/' + socket.remotePort);
    }
  } else {
    mh = multiaddr('/ip4/' + socket.remoteAddress + '/tcp/' + socket.remotePort);
  }

  return mh;
}