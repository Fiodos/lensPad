'use strict';

var debug = require('debug');
var log = debug('libp2p:websockets');
var SW = require('simple-websocket');
var isNode = require('detect-node');
var SWS = void 0;
if (isNode) {
  SWS = require('simple-websocket-server');
} else {
  SWS = {};
}
var mafmt = require('mafmt');
var contains = require('lodash.contains');
var Connection = require('interface-connection').Connection;

var CLOSE_TIMEOUT = 2000;
// const IPFS_CODE = 421

exports = module.exports = WebSockets;

function WebSockets() {
  if (!(this instanceof WebSockets)) {
    return new WebSockets();
  }

  this.dial = function (ma, options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!callback) {
      callback = function noop() {};
    }

    var maOpts = ma.toOptions();

    var socket = new SW('ws://' + maOpts.host + ':' + maOpts.port);

    var conn = new Connection(socket);

    socket.on('timeout', function () {
      conn.emit('timeout');
    });

    socket.on('error', function (err) {
      callback(err);
      conn.emit('error', err);
    });

    socket.on('connect', function () {
      callback(null, conn);
      conn.emit('connect');
    });

    conn.getObservedAddrs = function (cb) {
      return cb(null, [ma]);
    };

    return conn;
  };

  this.createListener = function (options, handler) {
    if (typeof options === 'function') {
      handler = options;
      options = {};
    }

    var listener = SWS.createServer(function (socket) {
      var conn = new Connection(socket);

      conn.getObservedAddrs = function (cb) {
        // TODO research if we can reuse the address in anyway
        return cb(null, []);
      };
      handler(conn);
    });

    var listeningMultiaddr = void 0;

    listener._listen = listener.listen;
    listener.listen = function (ma, callback) {
      if (!callback) {
        callback = function noop() {};
      }

      listeningMultiaddr = ma;

      if (contains(ma.protoNames(), 'ipfs')) {
        ma = ma.decapsulate('ipfs');
      }

      listener._listen(ma.toOptions(), callback);
    };

    listener._close = listener.close;
    listener.close = function (options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = { timeout: CLOSE_TIMEOUT };
      }
      if (!callback) {
        callback = function noop() {};
      }
      if (!options) {
        options = { timeout: CLOSE_TIMEOUT };
      }

      var closed = false;
      listener.once('close', function () {
        closed = true;
      });
      listener._close(callback);
      setTimeout(function () {
        if (closed) {
          return;
        }
        log('unable to close graciously, destroying conns');
        Object.keys(listener.__connections).forEach(function (key) {
          log('destroying %s', key);
          listener.__connections[key].destroy();
        });
      }, options.timeout || CLOSE_TIMEOUT);
    };

    // Keep track of open connections to destroy in case of timeout
    listener.__connections = {};
    listener.on('connection', function (socket) {
      var key = (~~(Math.random() * 1e9)).toString(36) + Date.now();
      listener.__connections[key] = socket;

      socket.on('close', function () {
        delete listener.__connections[key];
      });
    });

    listener.getAddrs = function (callback) {
      callback(null, [listeningMultiaddr]);
    };

    return listener;
  };

  this.filter = function (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs];
    }
    return multiaddrs.filter(function (ma) {
      if (contains(ma.protoNames(), 'ipfs')) {
        ma = ma.decapsulate('ipfs');
      }
      return mafmt.WebSockets.matches(ma);
    });
  };
}