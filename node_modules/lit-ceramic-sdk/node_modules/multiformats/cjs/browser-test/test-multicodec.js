'use strict';

var bytes = require('../src/bytes.js');
var assert = require('assert');
var raw = require('../src/codecs/raw.js');
var json = require('../src/codecs/json.js');
var codec = require('../src/codecs/codec.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);

const same = assert__default['default'].deepStrictEqual;
const test = it;
const testThrow = async (fn, message) => {
  try {
    await fn();
  } catch (e) {
    if (e.message !== message)
      throw e;
    return;
  }
  throw new Error('Test failed to throw');
};
describe('multicodec', () => {
  test('encode/decode raw', () => {
    const buff = raw.encode(bytes.fromString('test'));
    same(buff, bytes.fromString('test'));
    same(raw.decode(buff, 'raw'), bytes.fromString('test'));
  });
  test('encode/decode json', () => {
    const buff = json.encode({ hello: 'world' });
    same(buff, bytes.fromString(JSON.stringify({ hello: 'world' })));
    same(json.decode(buff), { hello: 'world' });
  });
  test('json.encoder', () => {
    const {encoder} = json;
    same(encoder === json.encoder, true, 'getter cached decoder');
    const buff = encoder.encode({ hello: 'world' });
    same(buff, bytes.fromString(JSON.stringify({ hello: 'world' })));
  });
  test('json.decoder', () => {
    const {decoder} = json;
    same(decoder === json.decoder, true, 'getter cached encoder');
    const buff = json.encode({ hello: 'world' });
    same(decoder.decode(buff), { hello: 'world' });
  });
  test('raw cannot encode string', async () => {
    await testThrow(() => raw.encode('asdf'), 'Unknown type, must be binary type');
  });
  test('add with function', () => {
    const blip = codec.codec({
      code: 200,
      name: 'blip',
      encode: a => a[1],
      decode: a => a
    });
    const two = bytes.fromString('two');
    const three = bytes.fromString('three');
    same(blip.encode([
      'one',
      two,
      three
    ]), two);
    same(blip.decode(three, 200), three);
  });
});
