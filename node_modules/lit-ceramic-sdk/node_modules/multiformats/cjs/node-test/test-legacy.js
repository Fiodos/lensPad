'use strict';

var buffer = require('buffer');
var assert = require('assert');
var legacy = require('../src/legacy.js');
var raw = require('../src/codecs/raw.js');
var json = require('../src/codecs/json.js');
var sha2 = require('../src/hashes/sha2.js');
var codec = require('../src/codecs/codec.js');
var cid = require('../src/cid.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);

const same = assert__default['default'].deepStrictEqual;
const test = it;
const testThrow = async (fn, message) => {
  try {
    await fn();
  } catch (e) {
    if (e.message !== message)
      throw e;
    return;
  }
  throw new Error('Test failed to throw');
};
const hashes = {
  [sha2.sha256.name]: sha2.sha256,
  [sha2.sha512.name]: sha2.sha512
};
describe('multicodec', () => {
  let raw$1;
  let json$1;
  let custom;
  let link;
  before(async () => {
    raw$1 = legacy(raw, { hashes });
    json$1 = legacy(json, { hashes });
    link = await raw$1.util.cid(buffer.Buffer.from('test'));
    custom = legacy(codec.codec({
      name: 'custom',
      code: 6787678,
      encode: o => {
        if (o.link) {
          assert__default['default'].ok(o.link.code);
          o.link = true;
        }
        return json$1.util.serialize({
          o,
          l: link.toString()
        });
      },
      decode: buff => {
        const obj = json$1.util.deserialize(buff);
        obj.l = link;
        if (obj.o.link)
          obj.link = cid.asCID(link);
        return obj;
      }
    }), { hashes });
  });
  test('encode/decode raw', () => {
    const buff = raw$1.util.serialize(buffer.Buffer.from('test'));
    same(buff, buffer.Buffer.from('test'));
    same(raw$1.util.deserialize(buff), buffer.Buffer.from('test'));
  });
  test('encode/decode json', () => {
    const buff = json$1.util.serialize({ hello: 'world' });
    same(buff, buffer.Buffer.from(JSON.stringify({ hello: 'world' })));
    same(json$1.util.deserialize(buff), { hello: 'world' });
  });
  test('cid', async () => {
    const cid = await raw$1.util.cid(buffer.Buffer.from('test'));
    same(cid.version, 1);
    same(cid.codec, 'raw');
    const {bytes} = await sha2.sha256.digest(buffer.Buffer.from('test'));
    same(cid.multihash, buffer.Buffer.from(bytes));
    const msg = 'Hasher for md5 was not provided in the configuration';
    testThrow(async () => await raw$1.util.cid(buffer.Buffer.from('test'), { hashAlg: 'md5' }), msg);
  });
  test('resolve', async () => {
    const fixture = custom.util.serialize({
      one: {
        two: { hello: 'world' },
        three: 3
      }
    });
    let value = { hello: 'world' };
    same(custom.resolver.resolve(fixture, 'o/one/two'), {
      value,
      remainderPath: ''
    });
    value = 'world';
    same(custom.resolver.resolve(fixture, 'o/one/two/hello'), {
      value,
      remainderPath: ''
    });
    value = link;
    same(custom.resolver.resolve(fixture, 'l/outside'), {
      value,
      remainderPath: 'outside'
    });
    await testThrow(() => custom.resolver.resolve(fixture, 'o/two'), 'Not found');
  });
  test('tree', () => {
    const fixture = custom.util.serialize({
      one: {
        two: { hello: 'world' },
        three: 3
      }
    });
    const arr = a => Array.from(a);
    const links = [
      '/o',
      '/o/one',
      '/o/one/two',
      '/o/one/two/hello',
      '/o/one/three',
      '/l'
    ];
    same(arr(custom.resolver.tree(fixture)), links);
    same(arr(json$1.resolver.tree(json$1.util.serialize('asdf'))), []);
  });
  test('cid API change', () => {
    const fixture = { link };
    const buff = custom.util.serialize(fixture);
    const decoded = custom.util.deserialize(buff);
    same(decoded.link, link);
  });
});
