export function codec<Name extends string, Code extends number, T>({ name, code, decode, encode }: {
    name: Name;
    code: Code;
    encode: (data: T) => Uint8Array;
    decode: (bytes: Uint8Array) => T;
}): Codec<Name, Code, T>;
/**
 * @template {number} Code
 * @template T
 * @typedef {import('./interface').BlockEncoder<Code, T>} BlockEncoder
 */
/**
 * @class
 * @template T
 * @template {string} Name
 * @template {number} Code
 * @implements {BlockEncoder<Code, T>}
 */
export class Encoder<T, Name extends string, Code extends number> implements BlockEncoder<Code, T> {
    /**
     * @param {Name} name
     * @param {Code} code
     * @param {(data:T) => Uint8Array} encode
     */
    constructor(name: Name, code: Code, encode: (data: T) => Uint8Array);
    name: Name;
    code: Code;
    encode: (data: T) => Uint8Array;
}
/**
 * @template {number} Code
 * @template T
 * @typedef {import('./interface').BlockDecoder<Code, T>} BlockDecoder
 */
/**
 * @class
 * @template {number} Code
 * @template T
 * @implements {BlockDecoder<Code, T>}
 */
export class Decoder<Code extends number, T> implements BlockDecoder<Code, T> {
    /**
     * @param {string} name
     * @param {Code} code
     * @param {(bytes:Uint8Array) => T} decode
     */
    constructor(name: string, code: Code, decode: (bytes: Uint8Array) => T);
    name: string;
    code: Code;
    decode: (bytes: Uint8Array) => T;
}
/**
 * @template {number} Code
 * @template T
 * @typedef {import('./interface').BlockCodec<Code, T>} BlockCodec
 */
/**
 * @class
 * @template {string} Name
 * @template {number} Code
 * @template T
 * @implements {BlockCodec<Code, T>}
 */
export class Codec<Name extends string, Code extends number, T> implements BlockCodec<Code, T> {
    /**
     * @param {Name} name
     * @param {Code} code
     * @param {(data:T) => Uint8Array} encode
     * @param {(bytes:Uint8Array) => T} decode
     */
    constructor(name: Name, code: Code, encode: (data: T) => Uint8Array, decode: (bytes: Uint8Array) => T);
    name: Name;
    code: Code;
    encode: (data: T) => Uint8Array;
    decode: (bytes: Uint8Array) => T;
    get decoder(): Decoder<Code, T>;
    get encoder(): Encoder<T, Name, Code>;
}
export type BlockEncoder<Code extends number, T> = import('./interface').BlockEncoder<Code, T>;
export type BlockDecoder<Code extends number, T> = import('./interface').BlockDecoder<Code, T>;
export type BlockCodec<Code extends number, T> = import('./interface').BlockCodec<Code, T>;
//# sourceMappingURL=codec.d.ts.map