/// <reference types="node" />
export default legacy;
export type MultihashHasher = import('./hashes/interface').MultihashHasher;
export type BlockCodec<Code extends number, T> = import('./codecs/interface').BlockCodec<Code, T>;
export type MultibaseCodec<T> = import('./bases/base').MultibaseCodec<T>;
/**
 * @template {number} Code
 * @template T
 * @param {BlockCodec<Code, T>} codec
 * @param {Object} options
 * @param {Object<string, MultihashHasher>} options.hashes
 */
declare function legacy<Code extends number, T>(codec: import("./codecs/interface").BlockCodec<Code, T>, { hashes }: {
    hashes: {
        [x: string]: MultihashHasher;
    };
}): {
    defaultHashAlg: string;
    codec: Code;
    util: {
        serialize: (o: T) => Buffer;
        deserialize: (b: Uint8Array) => T;
        cid: (buff: Buffer, opts?: {
            cidVersion?: 0 | 1 | undefined;
            hashAlg?: string | undefined;
        } | undefined) => Promise<OldCID>;
    };
    resolver: {
        resolve: (buff: Buffer, path: string) => {
            value: T;
            remainderPath: string;
        };
        tree: (buff: Uint8Array) => Iterable<string>;
    };
};
import { Buffer } from "buffer";
import OldCID from "cids";
//# sourceMappingURL=legacy.d.ts.map