'use strict';

var lpm = require('length-prefixed-message');
var PROTOCOL_ID = require('./protocol-id');
var varint = require('varint');
var range = require('lodash.range');
var parallel = require('run-parallel');

exports = module.exports = Dialer;

function Dialer() {
  if (!(this instanceof Dialer)) {
    return new Dialer();
  }
  var conn = void 0;

  // perform the multistream handshake
  this.handle = function (_conn, callback) {
    lpm.read(_conn, function (buffer) {
      var msg = buffer.toString().slice(0, -1);
      if (msg === PROTOCOL_ID) {
        lpm.write(_conn, new Buffer(PROTOCOL_ID + '\n'));
        conn = _conn;
        callback();
      } else {
        callback(new Error('Incompatible multistream'));
      }
    });
  };

  this.select = function (protocol, callback) {
    if (!conn) {
      return callback(new Error('multistream handshake has not finalized yet'));
    }

    lpm.write(conn, new Buffer(protocol + '\n'));
    lpm.read(conn, function (msgBuffer) {
      var msg = msgBuffer.toString().slice(0, -1);
      if (msg === protocol) {
        return callback(null, conn);
      }
      if (msg === 'na') {
        return callback(new Error(protocol + ' not supported'));
      }
    });
  };

  this.ls = function (callback) {
    lpm.write(conn, new Buffer('ls' + '\n'));
    var protos = [];
    lpm.read(conn, function (msgBuffer) {
      var size = varint.decode(msgBuffer); // eslint-disable-line
      var nProtos = varint.decode(msgBuffer, varint.decode.bytes);

      times(nProtos, function (n, next) {
        lpm.read(conn, function (msgBuffer) {
          protos.push(msgBuffer.toString().slice(0, -1));
          next();
        });
      }, function (err) {
        if (err) {
          return callback(err);
        }
        callback(null, protos);
      });
    });
  };
}

function times(i, work, callback) {
  parallel(range(i).map(function (i) {
    return function (callback) {
      return work(i, callback);
    };
  }), callback);
}