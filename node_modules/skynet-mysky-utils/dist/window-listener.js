"use strict";
exports.__esModule = true;
exports.monitorWindowError = exports.PromiseController = exports.dispatchedErrorEvent = exports.errorWindowClosed = void 0;
exports.errorWindowClosed = "window-closed";
exports.dispatchedErrorEvent = "catchError";
var PromiseController = /** @class */ (function () {
    function PromiseController() {
    }
    PromiseController.prototype.cleanup = function () {
        // Empty until implemented in monitorWindowError.
    };
    return PromiseController;
}());
exports.PromiseController = PromiseController;
/**
 * Checks if there has been an error from the window on an interval.
 *
 * @returns - The promise that rejects if the listener encounters an error from the remote window, and a controller that can abort the event listener and clean up the promise.
 */
function monitorWindowError() {
    var controller = new PromiseController();
    var abortController = new AbortController();
    var promise = new Promise(function (resolve, reject) {
        var handleEvent = function (event) {
            window.removeEventListener(exports.dispatchedErrorEvent, handleEvent);
            var err = event.detail;
            reject(err);
        };
        window.addEventListener(exports.dispatchedErrorEvent, handleEvent, {
            signal: abortController.signal
        });
        // Initialize cleanup function.
        controller.cleanup = function () {
            // Abort the event listener.
            abortController.abort();
            // Cleanup the promise.
            resolve();
        };
    });
    return { promise: promise, controller: controller };
}
exports.monitorWindowError = monitorWindowError;
//# sourceMappingURL=window-listener.js.map